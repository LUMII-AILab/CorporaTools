<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The Prague Markup Language (Version 1.1)</title><link rel="stylesheet" href="css/blue.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.68.1" /></head><body><div class="article" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="id182368"></a>The Prague Markup Language (Version 1.1)</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Petr</span> <span class="surname">Pajas</span></h3><div class="affiliation"><span class="orgname">Institute of Formal and Applied Linguistics, 
	Faculty of Mathematics and Physics<br /></span><div class="address"><p>Prague</p></div></div></div></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="2"><b>Revision History</b></th></tr><tr><td align="left">Revision 1.0.0</td><td align="left">5 Dec 2005</td></tr><tr><td align="left" colspan="2">
	  <p>Initial revision for UFAL technical report no. TR-2005-29</p>
	</td></tr><tr><td align="left">Revision 1.0.1</td><td align="left">4 Aug 2006</td></tr><tr><td align="left" colspan="2">
	  <p>Added revision history; added missing list of allowed attributes to the specification of the PML schema element <a href="#root.element"><code class="literal">root</code></a></p>
	</td></tr><tr><td align="left">Revision 1.1.0</td><td align="left">1 May 2006</td></tr><tr><td align="left" colspan="2">
	  <p>This revision introduces schema language versioning, 
            and several major changes concerning <a href="#sequence.element"><code class="literal">sequence</code></a>, 
            <a href="#element.element"><code class="literal">element</code></a>, and <a href="#root.element"><code class="literal">root</code></a> data types.
            In this revision, <a href="#element.element"><code class="literal">element</code></a> is no more a separate data type, 
            but only a syntactic construction of a sequence
            (similar to the <a href="#member.element"><code class="literal">member</code></a> subelement of <a href="#structure.element"><code class="literal">structure</code></a>). 
            A new data type <a href="#container.element"><code class="literal">container</code></a> is introduced which replaces
            the previous data type function of <a href="#element.element"><code class="literal">element</code></a>.
            Possible orderings of sequence elements can now be specified
            via a regular-grammar-based attribute <a href="#content_pattern.attribute"><code class="literal">content_pattern</code></a>.
          </p>
          <p>Newly introduced PML schema elements <a href="#import.element"><code class="literal">import</code></a> and <a href="#derive.element"><code class="literal">derive</code></a>
            provide modularization support for PML schemas.</p>
	  <p>This revision also restricts the format <a href="#ID.format"><code class="literal">ID</code></a> to 
            the <a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-NCName" target="_top"><code class="literal">NCName</code> production</a> of 
            <a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/" target="_top">Namespaces in XML</a> and
            introduces a set of new formats based on W3C XML Schema built-in simple types.
          </p>
	</td></tr><tr><td align="left">Revision 1.1.1</td><td align="left">26 Jun 2006</td></tr><tr><td align="left" colspan="2">
	  <p>Since this revision, the <a href="#root.element"><code class="literal">root</code></a> can also be of a container type.</p>
	</td></tr><tr><td align="left">Revision 1.1.2</td><td align="left">11 Jul 2006</td></tr><tr><td align="left" colspan="2">
	  <p>Since this revision, PML schema may be embedded in the
	    <a href="#header.schema.element"><code class="literal">schema</code></a> element of PML
	    instance header (in which case 
	    <code class="literal">href</code> attribute is omitted).</p>
	</td></tr><tr><td align="left">Revision 1.1.3</td><td align="left">20 Aug 2006</td></tr><tr><td align="left" colspan="2">
	  <p>This revision clarifies that
            <a href="#type.element"><code class="literal">type</code></a>, <a href="#root.element"><code class="literal">root</code></a>, <a href="#structure.element"><code class="literal">structure</code></a>, <a href="#element.element"><code class="literal">element</code></a>, <a href="#member.element"><code class="literal">member</code></a>, and <a href="#attribute.element"><code class="literal">attribute</code></a> names must match the
            <a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-NCName" target="_top"><code class="literal">NCName</code>
            production</a> of <a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/" target="_top">Namespaces
            in XML</a> and that <a href="#root.element"><code class="literal">root</code></a>, <a href="#member.element"><code class="literal">member</code></a>, and <a href="#element.element"><code class="literal">element</code></a> names must be different
            from <code class="literal">LM</code> and <code class="literal">AM</code>.
	  </p>
	  <p>Additional constraints on the
            declarations with role <code class="literal">#KNIT</code> were
            added and minor edits for improved clarity were made.</p>
	</td></tr><tr><td align="left">Revision 1.1.4</td><td align="left">19 July 2008</td></tr><tr><td align="left" colspan="2">
	  <p>An <a href="#attribute.element"><code class="literal">attribute</code></a> may also be of the type <a href="#constant.element"><code class="literal">constant</code></a>.</p>
	</td></tr><tr><td align="left">Revision 1.1.5</td><td align="left">13 March 2010</td></tr><tr><td align="left" colspan="2">
	  <p>
	    The <code class="literal">role</code> attribute cannot be used with the <a href="#type.element"><code class="literal">type</code></a> element.
	    The use of the <a href="#type.element"><code class="literal">type</code></a> attribute
	    in connection with a <a href="#derive.element"><code class="literal">derive</code></a> element
	    has been clarified.
	    The use of <code class="literal">xml:id</code> as an attribute name
	    explicitly allowed.
	  </p>
	</td></tr></table></div></div></div><hr /></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#id257466">1. Introduction</a></span></dt><dt><span class="section"><a href="#pml-data-types">2. PML data types</a></span></dt><dd><dl><dt><span class="section"><a href="#id257737">2.1. Character data type (cdata)</a></span></dt><dt><span class="section"><a href="#id257782">2.2. Enumerated atomic type</a></span></dt><dt><span class="section"><a href="#id257820">2.3. Constant atomic type</a></span></dt><dt><span class="section"><a href="#id257861">2.4. Structures</a></span></dt><dt><span class="section"><a href="#id257924">2.5. Lists</a></span></dt><dt><span class="section"><a href="#id258002">2.6. Alternatives</a></span></dt><dt><span class="section"><a href="#id258072">2.7. Sequences</a></span></dt><dt><span class="section"><a href="#id258123">2.8. Containers</a></span></dt></dl></dd><dt><span class="section"><a href="#pml-formats">3. Atomic data formats</a></span></dt><dt><span class="section"><a href="#pml-roles">4. PML roles</a></span></dt><dt><span class="section"><a href="#pml-header">5. Header of a PML instance</a></span></dt><dt><span class="section"><a href="#pml-schema">6. PML schema file</a></span></dt><dt><span class="section"><a href="#processing">7. Processing modular PML schemas</a></span></dt><dd><dl><dt><span class="section"><a href="#id262877">7.1. Processing <code class="literal">import</code> elements</a></span></dt><dt><span class="section"><a href="#id263440">7.2. Processing <code class="literal">derive</code> elements</a></span></dt></dl></dd><dt><span class="section"><a href="#revisions">8. Numbering revisions of PML schemas</a></span></dt><dt><span class="section"><a href="#pml-pmlref">9. References in PML</a></span></dt><dt><span class="section"><a href="#pml-recommend">10. Final recommendations</a></span></dt><dd><dl><dt><span class="section"><a href="#pml-layers">10.1. Layers of annotation</a></span></dt><dt><span class="section"><a href="#pml-tools">10.2. Tools</a></span></dt></dl></dd><dt><span class="appendix"><a href="#pml-relaxng">Relax NG for PML schema</a></span></dt><dt><span class="appendix"><a href="#pml-examples">Examples</a></span></dt><dd><dl><dt><span class="section"><a href="#id264666">1. Dependency trees</a></span></dt><dt><span class="section"><a href="#pml-example-constituency">2. Constituency trees</a></span></dt><dt><span class="section"><a href="#id265018">3. Internal references</a></span></dt><dt><span class="section"><a href="#id265183">4. External references</a></span></dt><dt><span class="section"><a href="#id265472">5. Modular schemas</a></span></dt></dl></dd></dl></div><p class="draft"><b>Revision history markup. </b></p><div class="added">This is how a paragraph added between
    two latest major revisions looks like.</div><div class="changed"><p class="draft">This is how a paragraph
  modified between two latest major revisions looks like.</p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id257466"></a>1. Introduction</h2></div></div></div><p>
      The Prague Markup Language (PML) is a
      common basis of an open family of XML-based data formats
      for representing rich linguistic annotations of texts, such as
      morphological tagging, dependency trees, etc. PML is an on-going
      project in its early stage. This documentation reflects the
      current status of the PML development.
    </p><p>
      PML tries to identify common abstract data types and structures
      used in linguistic annotations of texts as well as in lexicons (especially
      those intended for machine use in NLP) and other
      types of linguistic data, and to define a unified,
      straightforward and coherent XML-based representation for values
      of these abstract types. PML also emphasizes the following aspects of
      linguistic annotation: the stand-off annotation methodology,
      possibility to stack layers of annotation one over another, and
      extensive cross-referencing. PML also tries to retain
      simplicity, so that PML instances (actual PML representation of the
      data) could be processed with conventional XML-oriented tools.
    </p><p>Unlike, e.g. TEI XML, XHTML or DocBook, PML by itself is not a full
      XML vocabulary but rather a system for defining such vocabularies.
    </p><p>A fully specified XML vocabulary satisfying the requirements
      constituted in this document is called an <em class="firstterm">application
      of PML</em>. An Application of PML is formally defined using a
      specialized XML file called <em class="firstterm">PML schema</em>. 
      PML schema provides one level of abstraction
      over standard XML-schema languages such as <a href="http://www.relaxng.org/" target="_top">Relax NG</a> or <a href="http://www.w3.org/XML/Schema" target="_top">W3C XML Schemas</a>.  It
      defines an XML vocabulary and document structure by means of
      <em class="firstterm">PML data types</em> and <em class="firstterm">PML
      roles</em>. An XML document conforming to a
      PML schema is a PML <em class="firstterm">instance</em> of the
      schema. PML data types,
      described in detail in <a href="#pml-data-types" title="2.&#xA0;PML data types">Section 2, “PML data types”</a>, include
      atomic types (identifiers, strings, integers, enumerated types,
      id-references, etc.), and complex types, which are composed from 
      abstract types such as attribute-value structures (AVS), 
      lists, alternatives, and mixed-type sequences.
      We refer to a value of a complex type as a <em class="firstterm">construct</em>.
      The information provided by PML roles is orthogonal to data
      typing. It identifies a construct as a bearer
      of an additional higher-level property of the annotation, such as
      being a node of a dependency tree, or being a unique identifier
      (see <a href="#pml-roles" title="4.&#xA0;PML roles">Section 4, “PML roles”</a>).
    </p><p>Based on a PML schema of a particular application of PML,
      it is possible to automatically derive a corresponding Relax NG schema
      that conventional XML-oriented tools can use to validate actual
      PML <em class="firstterm">instances</em> (see <a href="#pml-tools" title="10.2.&#xA0;Tools">Section 10.2, “Tools”</a>).
    </p><p>All XML tags used in applications of PML belong to a
       dedicated XML namespace
      </p><div class="literallayout"><p><code class="filename">http://ufal.mff.cuni.cz/pdt/pml/</code></p></div><p>
       We will
       refer to the above namespace as <em class="firstterm">PML namespace</em>.
    </p><p>
      PML schema files use
       the following XML namespace referred to as <em class="firstterm">PML schema namespace</em>:
      </p><div class="literallayout"><p><code class="filename">http://ufal.mff.cuni.cz/pdt/pml/schema/</code></p></div><p>
       Currently PML reserves three element names from the PML
       namespace for the representation of the technical elements:
       <code class="literal">LM</code> (for bracketing list members), <code class="literal">AM</code>
       (for bracketing alternative members), and <code class="literal">head</code> (for a
      common PML instance header described in detail in <a href="#pml-header" title="5.&#xA0;Header of a PML instance">Section 5, “Header of a PML instance”</a>).
    </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="pml-data-types"></a>2. PML data types</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#id257737">2.1. Character data type (cdata)</a></span></dt><dt><span class="section"><a href="#id257782">2.2. Enumerated atomic type</a></span></dt><dt><span class="section"><a href="#id257820">2.3. Constant atomic type</a></span></dt><dt><span class="section"><a href="#id257861">2.4. Structures</a></span></dt><dt><span class="section"><a href="#id257924">2.5. Lists</a></span></dt><dt><span class="section"><a href="#id258002">2.6. Alternatives</a></span></dt><dt><span class="section"><a href="#id258072">2.7. Sequences</a></span></dt><dt><span class="section"><a href="#id258123">2.8. Containers</a></span></dt></dl></div><p>
      The PML currently recognizes the following abstract data types
      described below. Specific types are are built from abstract types
      means of composition. For each abstract type,
      an example of a concrete declaration in the PML schema is given toghether
      with examples of the XML representation of the corresponding data in an
      instance conforming to that schema.
    </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id257737"></a>2.1. Character data type (cdata)</h3></div></div></div><p>Atomic values are literal strings. The exact content
	    of an atomic value may be further specified as its format
	    (see <a href="#pml-formats" title="3.&#xA0;Atomic data formats">Section 3, “Atomic data formats”</a>). In the XML, atomic values are (depending
            on the context) represented in XML either as a CDATA (i.e. text) content
            of an element or as an attribute value.
	  </p><div class="example"><a id="id257753"></a><p class="title"><b>Example 1. Example of a cdata declaration</b></p><pre class="programlisting">

&lt;type name="id.type" xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/"&gt;
  &lt;cdata format="anyURI"/&gt;
&lt;/type&gt;

	    </pre></div><div class="example"><a id="id257767"></a><p class="title"><b>Example 2. Example of a XML representation of cdata value
	    occurring in some data field
	    </b></p><pre class="programlisting">

&lt;link&gt;http://www.mff.cuni.cz&lt;/link&gt;

	    </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id257782"></a>2.2. Enumerated atomic type</h3></div></div></div><p>
	    An atomic-value type defined as an exhaustive list of possible values of that type.
	  </p><div class="example"><a id="id257791"></a><p class="title"><b>Example 3. Example of an enumerated type declaration</b></p><pre class="programlisting">

&lt;type name="pos.type" xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/"&gt;
  &lt;choice&gt;
    &lt;value&gt;verb&lt;/value&gt;
    &lt;value&gt;noun&lt;/value&gt;
    &lt;value&gt;adjective&lt;/value&gt;
    &lt;value&gt;adverb&lt;/value&gt;
  &lt;/choice&gt;
&lt;/type&gt;

	    </pre></div><div class="example"><a id="id257802"></a><p class="title"><b>Example 4. Example of a XML representation of a value of the enumerated type
	    occurring within some data field
	    </b></p><pre class="programlisting">

&lt;pos&gt;verb&lt;/pos&gt;

	    </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id257820"></a>2.3. Constant atomic type</h3></div></div></div><p>This is like an enumerated type with just one possible
	value. Therefore, whenever e.g. an attribute or structure
	member is declared with content is of a constant type, its
	value must be equal to this constant. Moreover, unless the
	attribute or member is required, the constant value is
	assummed when the attribute or member is omitted.
	</p><div class="example"><a id="id257832"></a><p class="title"><b>Example 5. Example of an enumerated type declaration</b></p><pre class="programlisting">

&lt;type name="nodetype.type" xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/"&gt;
  &lt;constant&gt;terminal&lt;/constant&gt;
&lt;/type&gt;

	    </pre></div><div class="example"><a id="id257846"></a><p class="title"><b>Example 6. Example of a XML representation of a constant value 
	    of an attribute 'type'. The applications should consider
	    two elements below equivalent, since the value of the attribute
	    'type' on the element 'node' is implied by the PML schema.
	    </b></p><pre class="programlisting">

&lt;node/&gt;
&lt;node type="terminal"/&gt;

	    </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id257861"></a>2.4. Structures</h3></div></div></div><p>A structure is a versatile PML abstract type.
            Sometimes it is called a feature-structure, attribute-value structure or
	    AVS. To avoid confusion with XML attributes, we refer
	    to attributes of a structure as
            <em class="firstterm">members</em>. 
            A structure is similar to a <code class="literal">struct</code> type in the C
	    programming language. 
            A structure is fully specified by names, types
	    and optionally roles for each of its members. 
            Different members of the structure must have distinct names.
            The structure is represented in XML by an element
	    whose only content are attributes and/or sub-elements representing the members of the
	    structure. An attribute or sub-element representing a
            member is named by the member and its content is the XML
            representation of the member's value.
            The order of members in the structure as represented in
            XML may be arbitrary. Whether a particular
            member is represented by an attribute or a sub-element is
            specified in the PML schema, however, only members with
	    values of atomic types can be represented by
	    attributes. Some structure members
	    may in the PML schema be formally declared as required, 
            in which case they must appear in the structure and its
            XML representation and must have non-empty content.
	    All members not explicitly declared as required are
	    optional.
	  </p><div class="example"><a id="id257890"></a><p class="title"><b>Example 7. Example of a structure declaration</b></p><pre class="programlisting">

&lt;type name="morph-analysis.type" xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/"&gt;
  &lt;structure&gt;
    &lt;member name="id" role="#ID" required="1" as_attribute="1"&gt;
      &lt;cdata format="ID"/&gt;
    &lt;/member&gt;
    &lt;member name="pos" required="1" type="pos.type"/&gt;
    &lt;member name="case" type="case.type"/&gt;
    &lt;member name="gender"&gt;
      &lt;!-- ... --&gt;
    &lt;/member&gt;
  &lt;/structure&gt;
&lt;/type&gt;

	    </pre></div><div class="example"><a id="id257902"></a><p class="title"><b>Example 8. Example of a XML representation of a structure</b></p><pre class="programlisting">

&lt;some_element id="a1" xmlns="http://ufal.mff.cuni.cz/pdt/pml/"&gt;
  &lt;pos&gt;noun&lt;/pos&gt;
  &lt;case&gt;&lt;AM&gt;1&lt;/AM&gt;&lt;AM&gt;4&lt;/AM&gt;&lt;/case&gt;
&lt;/some_element&gt;

	    </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id257924"></a>2.5. Lists</h3></div></div></div><p>
	    PML offers unified representation of both ordered and
	    unordered lists of constructs of the same type (the
	    <em class="firstterm">list member type</em>).  PML lists
	    represent data similar to arrays in various
	    programming languages.  An XML element representing a
	    construct of a list type must as its only child-nodes have
	    either zero or more XML elements named <code class="literal">LM</code> (“<span class="quote">List Member</span>”),
	    each representing a construct of the list member type, or
	    else (as a compact representation of singleton lists) its
	    content must be of the list member type.  List member type
	    can not be a list, i.e.  lists of lists are not
	    allowed. Technically, the difference between ordered and
	    unordered lists is only in the declaration. Ordered lists
	    may still contain repeated member (members with the same
	    value). Applications are only required to preserve
	    the ordering of ordered lists.
	  </p><div class="example"><a id="id257954"></a><p class="title"><b>Example 9. Example of a list declaration</b></p><pre class="programlisting">

&lt;type name="morph-analyses.type" xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/"&gt;
  &lt;list type="morph-analysis.type" ordered="1"/&gt;
&lt;/type&gt;

	    </pre></div><div class="example"><a id="id257969"></a><p class="title"><b>Example 10. Example of an XML representation of a list</b></p><pre class="programlisting">

&lt;analyses xmlns="http://ufal.mff.cuni.cz/pdt/pml/"&gt;
  &lt;LM id="a1"&gt;
    &lt;pos&gt;noun&lt;/pos&gt;
    &lt;case&gt;&lt;AM&gt;1&lt;/AM&gt;&lt;AM&gt;4&lt;/AM&gt;&lt;/case&gt;
  &lt;/LM&gt;
  &lt;LM id="a2"&gt;
    &lt;pos&gt;adjective&lt;/pos&gt;
    &lt;case&gt;3&lt;/case&gt;
    &lt;gender&gt;fem&lt;/gender&gt;
  &lt;/LM&gt;
  &lt;LM id="a3"&gt;
    &lt;pos&gt;verb&lt;/pos&gt;
  &lt;/LM&gt;
&lt;/analyses&gt;

	    </pre></div><div class="example"><a id="id257980"></a><p class="title"><b>Example 11. Example of an XML representation of a list with only one element (compact representation)</b></p><pre class="programlisting">

&lt;analyses id="a1"&gt;
  &lt;pos&gt;noun&lt;/pos&gt;
  &lt;case&gt;&lt;AM&gt;1&lt;/AM&gt;&lt;AM&gt;4&lt;/AM&gt;&lt;/case&gt;
&lt;/analyses&gt;

	    </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id258002"></a>2.6. Alternatives</h3></div></div></div><p>
	    Similar to unordered lists but different in usage and semantics 
	    are alternatives. Alternatives can be used to represent
	    data where usually one value of a certain type is used,
	    but under some circumstances several alternative (or parallel) values
	    are allowed. An XML element representing an alternative 
	    of constructs of a certain type (<em class="firstterm">alternative member type</em>)
	    is either a representation of a construct of that type
            (in case of a single value, i.e. no actual alternative values) or
	    has as its only child-nodes two or more XML elements named
	    <code class="literal">AM</code> (“<span class="quote">Alternative Member</span>”),
	    each of which represents a construct of the alternative member type.
	    Alternative member type must not be an alternative, i.e.
	    alternatives of alternatives are not allowed.
	  </p><div class="example"><a id="id258030"></a><p class="title"><b>Example 12. Example of a alternative declaration</b></p><pre class="programlisting">

&lt;type name="case.type" xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/"&gt;
  &lt;alt&gt;
    &lt;container&gt;
      &lt;attribute name="probability"&gt;&lt;cdata format="float"/&gt;&lt;/attribute&gt;
      &lt;cdata format="nonNegativeInteger"/&gt;
    &lt;/container&gt;
  &lt;/alt&gt;
&lt;/type&gt;

	    </pre></div><div class="example"><a id="id258041"></a><p class="title"><b>Example 13. Example of an XML representation of an alternative</b></p><pre class="programlisting">

&lt;case&gt;
  &lt;AM probability="0.7"&gt;1&lt;/AM&gt;
  &lt;AM probability="0.3"&gt;4&lt;/AM&gt;
&lt;/case&gt;

	    </pre></div><div class="example"><a id="id258060"></a><p class="title"><b>Example 14. Example of an XML representation of an alternative with only one member (compact representation)</b></p><pre class="programlisting">

&lt;case probability="1.0"&gt;7&lt;/case&gt;

	    </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id258072"></a>2.7. Sequences</h3></div></div></div><div class="changed"><p>Sequences are
	    similar to ordered lists but do not require their member
	    constructs to be of the same type.  Each member of a
	    sequence is represented by an XML element whose name is
	    bound in the sequence definition with the type of the
	    construct it bears and whose content represents the value.
	    The order and number of occurrences of elements in a
	    sequence may be specified by a regular expression or left
	    unrestricted.            
	  </p></div><div class="example"><a id="id258089"></a><p class="title"><b>Example 15. Example of a sequence declaration</b></p><pre class="programlisting">

&lt;type name="chapter-content.type" xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/"&gt;
  &lt;sequence content_pattern="title, para*, section*, see-also?"&gt;
    &lt;element name="title"&gt;&lt;cdata format="any"/&gt;&lt;/element&gt;
    &lt;element name="para" type="para.type"/&gt;
    &lt;element name="section" type="section.type"/&gt;
  &lt;/sequence&gt;
&lt;/type&gt;

	    </pre></div><div class="example"><a id="id258101"></a><p class="title"><b>Example 16. Example of an XML representation of a a sequence</b></p><pre class="programlisting">

&lt;chapter&gt;
  &lt;title&gt;Introduction&lt;/title&gt;
  &lt;para&gt;....&lt;/para&gt;
  &lt;para&gt;....&lt;/para&gt;
  &lt;section&gt;...&lt;/section&gt;
  &lt;section&gt;...&lt;/section&gt;
  &lt;section&gt;...&lt;/section&gt;
  &lt;see-also&gt;...&lt;/see-also&gt;
&lt;/chapter&gt;

	    </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id258123"></a>2.8. Containers</h3></div></div></div><div class="added"><p>
            Containers are similar but simpler to structures and can
            be used to annotate a piece of data by a set of
            attribute-value pairs with text-only values.  They are
            represented in XML by an element whose content is the data
            and XML attributes are the annotation. The content of a
            container can be of any type except for a container and
            structure.
            </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                Because of the compact representation of
                singleton lists and alternatives, a special care should be
                taken when using containers with content whose type is a
                list or alternative of containers or structures in order to avoid possible
                collisions between names of the attributes of the container and 
                attributes or members rendered as attribute of the contained
                (singleton) container or structure. (This problem also applies to
                type derivation and also to inheritance which is to appear in a future revision of this specification).
                To avoid such problems, applications serializing PML data to XML are allowed to
                surround singleton list or alternative members within a container by
                <code class="literal">LM</code> or <code class="literal">AM</code> tags respectively,
                and they must do so if a name collision is apparent from the PML schema.
              </p></div><p>
          </p></div><div class="example"><a id="id258172"></a><p class="title"><b>Example 17. Example of a container declaration</b></p><pre class="programlisting">

&lt;type name="chapter.type" xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/"&gt;
  &lt;container type="chapter-content.type"&gt;
    &lt;attribute name="id" role="#ID" required="1"&gt;
      &lt;cdata format="ID"/&gt;
    &lt;/attribute&gt;
    &lt;attribute name="autor.rf" &gt;
      &lt;cdata format="PMLREF"/&gt;
    &lt;/attribute&gt;
  &lt;/sequence&gt;
&lt;/type&gt;

	    </pre></div><div class="example"><a id="id258184"></a><p class="title"><b>Example 18. Example of an XML representation of a container</b></p><pre class="programlisting">

&lt;chapter id="ch1" author.rf="authors#johnsmith"&gt;
  &lt;title&gt;Introduction&lt;/title&gt;
  &lt;para&gt;....&lt;/para&gt;
  &lt;!-- ...etc... --&gt;
&lt;/chapter&gt;

	    </pre></div></div></div><div class="changed"><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="pml-formats"></a>3. Atomic data formats</h2></div></div></div><p>
      PML currently recognizes the follwoing atomic data formats:
      In the future, specification for more formats will be added and/or
      some generic mechanism for introducing user-defined atomic formats will be added.
    </p><div class="variablelist"><dl><dt><a id="any.format"></a><span class="term"><code class="literal">any</code></span></dt><dd><p>Arbitrary string of characters (used in all cases not covered by the formats below).</p></dd><dt><a id="ID.format"></a><span class="term"><code class="literal">ID</code></span></dt><dd><p>
	    An identifier string, i.e. a string
	    satisfying the
	    <a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-NCName" target="_top"><code class="literal">NCName</code> production</a> of 
             the W3C specification <a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/" target="_top">Namespaces in XML</a>.
            Note in particular that the specification explicitly forbids a colon (<code class="literal">:</code>) to 
            occur within an identifier.
	  </p><div class="informalexample"><p>Example: <code class="literal">ab</code>, <code class="literal">doc1.para2</code>, and <code class="literal">_d3p9_34-a2</code>,
                 are all valid identifiers,</p><p>(whereas <code class="literal">-ab</code>, <code class="literal">234a</code>, and <code class="literal">a:x34</code>
                 are all <span class="emphasis"><em>invalid</em></span>).</p></div></dd><dt><a id="PMLREF.format"></a><span class="term"><code class="literal">PMLREF</code></span></dt><dd><p>
	    An atomic value which either is of the <a href="#ID.format"><code class="literal">ID</code></a> format
            described above, or consists of two substrings of the format <a href="#ID.format"><code class="literal">ID</code></a>
	    delimited by the character <code class="literal">#</code>.
	    Values of this format usually represent a reference (link),
	    see <a href="#pml-pmlref" title="9.&#xA0;References in PML">Section 9, “References in PML”</a>.
	  </p><div class="informalexample"><p>Example: <code class="literal">doc1#chap2-para3</code> or <code class="literal">doc1</code>.</p></div></dd><dt><a id="other.format"></a><span class="term">Formats borrowed from the W3C XML Schema specification:</span></dt><dd><p>
	    PML further recognizes the following selected <a href="http://www.w3.org/TR/xmlschema-0/" target="_top">XML Schema</a> built-in <a href="http://www.w3.org/TR/xmlschema-0/#CreatDt" target="_top">simple types</a>
            as PML <a href="#cdata.element"><code class="literal">cdata</code></a> formats
	    (each format is specified to cover the lexical space of the corresponding simple type in the XML Schema specification without
            consraining facets):
	    <span class="simplelist">
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#string" target="_top">string</a>
	      , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#normalizedString" target="_top">normalizedString</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#token" target="_top">token</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#base64Binary" target="_top">base64Binary</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#hexBinary" target="_top">hexBinary</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#integer" target="_top">integer</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#positiveInteger" target="_top">positiveInteger</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#negativeInteger" target="_top">negativeInteger</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#nonNegativeInteger" target="_top">nonNegativeInteger</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#nonPositiveInteger" target="_top">nonPositiveInteger</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#long" target="_top">long</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#unsignedLong" target="_top">unsignedLong</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#int" target="_top">int</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#unsignedInt" target="_top">unsignedInt</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#short" target="_top">short</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#unsignedShort" target="_top">unsignedShort</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#byte" target="_top">byte</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#unsignedByte" target="_top">unsignedByte</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#decimal" target="_top">decimal</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#float" target="_top">float</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#double" target="_top">double</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#boolean" target="_top">boolean</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#duration" target="_top">duration</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#dateTime" target="_top">dateTime</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#date" target="_top">date</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#time" target="_top">time</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#gYear" target="_top">gYear</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#gYearMonth" target="_top">gYearMonth</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#gMonth" target="_top">gMonth</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#gMonthDay" target="_top">gMonthDay</a>
              ,               
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#gDay" target="_top">gDay</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#Name" target="_top">Name</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#NCName" target="_top">NCName</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#anyURI" target="_top">anyURI</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#language" target="_top">language</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#IDREF" target="_top">IDREF</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#IDREFS" target="_top">IDREFS</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#NMTOKEN" target="_top">NMTOKEN</a>
              , 
		<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/datatypes.html#NMTOKENS" target="_top">NMTOKENS</a>
              </span>
	    </p></dd></dl></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="pml-roles"></a>4. PML roles</h2></div></div></div><p>PML roles indicate a formal role that a given 
      construct plays in the annotation schema. Roles are orthogonal to types,
      but usually are compatible only with certain types of constructs.
      Roles are primarily intended to be used by applications processing
      the data. So far the following roles have been specified:
    </p><div class="variablelist"><dl><dt><a id="TREES.pmlrole"></a><span class="term">#TREES</span></dt><dd><p>
	    Only applicable to list or sequence constructs.
	    This role identifies a construct whose member constructs represent
	    dependency or constituency trees.
	  </p></dd><dt><a id="NODE.pmlrole"></a><span class="term">#NODE</span></dt><dd><p>Only applicable to a structure or a sequence-member construct.
	    This role identifies a node of a dependency or constituency tree.
	  </p></dd><dt><a id="CHILDNODES.pmlrole"></a><span class="term">#CHILDNODES</span></dt><dd><div class="changed"><p>
            Only applicable to a member of a structure 
	    with the role <a href="#NODE.pmlrole"><code class="literal">#NODE</code></a> or
	    a list or sequence content type of a container with the role
	    <a href="#NODE.pmlrole"><code class="literal">#NODE</code></a>.
	    This role identifies a construct representing a list of child nodes
	    of a node in a dependency or constituency tree.
	  </p></div></dd><dt><a id="ID.pmlrole"></a><span class="term">#ID</span></dt><dd><p>Only applicable to an atomic construct,
	    typically with the format <a href="#ID.format"><code class="literal">ID</code></a>.
	    A value with this role uniquely identifies
	    a construct (a structure, sequence, container, etc.) in
	    the PML instance. This means that all values with the role
	    <a href="#ID.pmlrole"><code class="literal">#ID</code></a> within a PML instance are distinct..
	  </p></dd><dt><a id="KNIT.pmlrole"></a><span class="term">#KNIT</span></dt><dd><div class="changed"><p>
            This role indicates that the application may resolve the
            atomic value(s) as PML references and replace their
            content with copies of referenced PML constructs. In case
            of an in-memory representation, the application may even
            arrange the data structures so that the PML reference is
            replaced by a direct pointer to or a shared copy of the
            corresponding data structure in the referenced PML
            construct in a way that allows accessing the referenced
            data structure as if it were part of the referring PML
            instance and so that change to it in any of the instances
            immediately causes the same change to be visible to the
            other.
	  </p></div><p>
	    This role is only applicable to either:
            </p><div class="itemizedlist"><ul type="disc"><li><p>a structure member of <a href="#cdata.element"><code class="literal">cdata</code></a>  type with the PMLREF format</p></li><li><p>a sequence element of <a href="#cdata.element"><code class="literal">cdata</code></a>  type with the PMLREF format</p></li><li><div class="changed"><p>a list of <a href="#cdata.element"><code class="literal">cdata</code></a> members with the PMLREF format.
                  The list must occur in a container or as a structure member.
                </p></div></li></ul></div><p>
	  </p></dd><dt><a id="ORDER.pmlrole"></a><span class="term">#ORDER</span></dt><dd><p>
	    This role identifies a structure member containing
	    a non-negative integer value used for ordering
	    nodes in an ordered tree.
	  </p></dd><dt><a id="HIDE.pmlrole"></a><span class="term">#HIDE</span></dt><dd><p>
	    This role identifies a structure member whose non-zero
            non-empty value indicates that an application may hide the
            structure from the user.
	  </p></dd></dl></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="pml-header"></a>5. Header of a PML instance</h2></div></div></div><p>Every PML instance starts with the <code class="literal">header</code> element
      which must occur as the first sub-element of the
      document element. The header element has the following
      sub-elements:
      </p><div class="variablelist"><dl><dt><a id="header.schema.element"></a><span class="term"><code class="literal">schema</code></span></dt><dd><p>Associates the instance with a PML schema file, indicating
	      that the instance conforms to the associated schema.
	    </p><div class="changed"><p>The associated PML schema may be either <span class="emphasis"><em>external</em></span>, in
	      which case its filename or URL is specified in the attribute
	      <code class="literal">href</code>,
	      or <span class="emphasis"><em>internal</em></span>, in which case there is no
	      <code class="literal">href</code> attribute and
	      the <code class="literal">schema</code> element
	      contains a single subelement <a href="#pml_schema.element"><code class="literal">pml_schema</code></a>
	      from PML schema namespace containing the definition of
	      the associated PML schema as specified in
	      <a href="#pml-schema" title="6.&#xA0;PML schema file">Section 6, “PML schema file”</a>.
	    </p></div></dd><dt><a id="header.references.element"></a><span class="term"><code class="literal">references</code></span></dt><dd><p>This element contains zero or more <code class="literal">reffile</code>
	      sub-elements, each of which maps a filename or URL (attribute
	      <code class="literal">href</code>) of some external
	      resource to an identifier (attribute <code class="literal">id</code>)
	      used as aliases when referring to the resource from the instance 
	      (see <a href="#pml-pmlref" title="9.&#xA0;References in PML">Section 9, “References in PML”</a>).
	      If the external resource is an instance
	      bound with the current instance as declared
	      in the PML schema, then <code class="literal">reffile</code> 
	      must have also a third attribute, <code class="literal">name</code>,
	      containing the name used in the tag
	      <a href="#reference.element"><code class="literal">reference</code></a> in the PML schema declaration
	      of the bound instance. For every resource bound
	      to the instance in the PML schema (using 
	      <a href="#reference.element"><code class="literal">reference</code></a> tag) there must be
	      a corresponding <code class="literal">reffile</code>.
	    </p></dd></dl></div><p>
    </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="pml-schema"></a>6. PML schema file</h2></div></div></div><p>
      In this section, the syntax of
      a PML schema file is specified.
      We describe the content of individual PML schema elements 
      by formal patterns similar to the grammar used in DTD for
      element-content model specification:
    </p><div class="variablelist"><dl><dt><span class="term"><em class="replaceable"><code>name</code></em></span></dt><dd><p>lower-case literals denote names of XML elements</p></dd><dt><span class="term"><code class="literal">PCDATA</code></span></dt><dd><p>denotes arbitrary text content</p></dd><dt><span class="term"><code class="literal">EMPTY</code></span></dt><dd><p>denotes empty content</p></dd><dt><span class="term"><code class="literal">(</code>...<code class="literal">)</code>
	</span></dt><dd><p>brackets delimit groups of adjacent content</p></dd><dt><span class="term"><code class="literal">?</code></span></dt><dd><p>indicates that the element or group whose
	specification immediately precedes is optional</p></dd><dt><span class="term"><code class="literal">*</code></span></dt><dd><p>indicates that the element or group whose
	specification immediately can be repeated</p></dd><dt><span class="term"><code class="literal">|</code></span></dt><dd><p>separates specifications of exclusively alternative content</p></dd><dt><span class="term"><code class="literal">,</code></span></dt><dd><p>separates specifications of adjacent content</p></dd></dl></div><p>
      A formal definition of the PML schema file syntax is available as a
      Relax NG schema, see <a href="#pml-relaxng" title="Relax&#xA0;NG for PML schema"><i>Relax NG for PML schema</i></a>.
    </p><p>
      All elements of the PML schema file belong to the PML schema
      namespace. The following elements may occur in a PML schema:
    </p><div class="changed"><div class="variablelist"><dl><dt><a id="pml_schema.element"></a><span class="term"><code class="literal">pml_schema</code></span></dt><dd><p>
	    This is the root element of a PML schema file. It may have no attributes (except
	    for the <code class="literal">xmlns</code> declaration of the
	    PML-schema namespace). It consists of an optional <a href="#description.element"><code class="literal">description</code></a>,
	    declarations of common instance <a href="#reference.element"><code class="literal">reference</code></a>s,
	    Schema modularization instructions 
	    <a href="#import.element"><code class="literal">import</code></a> and <a href="#derive.element"><code class="literal">derive</code></a>,
	    a <a href="#root.element"><code class="literal">root</code></a> declaration
	    and zero or more declarations of named types (<a href="#type.element"><code class="literal">type</code></a>).
	  </p><p>
	    PML schemas which contain no <a href="#import.element"><code class="literal">import</code></a> and <a href="#derive.element"><code class="literal">derive</code></a> instructions are called
	    <em class="firstterm">simplified PML schemas</em>.  The
	    section <a href="#processing" title="7.&#xA0;Processing modular PML schemas">Section 7, “Processing modular PML schemas”</a> describes how
	    <a href="#import.element"><code class="literal">import</code></a> and <a href="#derive.element"><code class="literal">derive</code></a> instructions are to be
	    processed in order to obtain an equivalent simplified PML
	    schema.
	  </p><div class="added"><div class="variablelist"><p class="title"><b>Attributes</b></p><dl><dt><span class="term"><code class="literal">version</code></span></dt><dd><p>Version of the PML specification the schema conforms to, currently
                  <code class="literal">1.1</code>
                </p></dd></dl></div></div><div class="changed"><p><b>Content. </b><code class="literal">(<a href="#revision.element">revision</a>?, <a href="#description.element">description</a>?, <a href="#reference.element">reference</a>*, <a href="#import.element">import</a>*, <a href="#derive.element">derive</a>*, <a href="#root.element">root</a>?, <a href="#type.element">type</a>*)</code></p></div></dd></dl></div></div><div class="added"><div class="variablelist"><dl><dt><a id="revision.element"></a><span class="term"><code class="literal">revision</code></span></dt><dd><p>This optional element is used to assign a revision number to a particular version of the PML schema,
	    see <a href="#revisions" title="8.&#xA0;Numbering revisions of PML schemas">Section 8, “Numbering revisions of PML schemas”</a>
	  </p><p><b>Content. </b><code class="literal">PCDATA</code></p></dd></dl></div></div><div class="variablelist"><dl><dt><a id="description.element"></a><span class="term"><code class="literal">description</code></span></dt><dd><p>This element provides an optional short description of
	  the PML schema.</p><p><b>Content. </b><code class="literal">PCDATA</code></p></dd><dt><a id="reference.element"></a><span class="term"><code class="literal">reference</code></span></dt><dd><p>
	    This element declares that each instance of the PML
	    schema is bound with another PML instance (usually of a
	    different PML schema) and provides a hint for an
	    application on how to process the bound instance.</p><div class="variablelist"><p class="title"><b>Attributes</b></p><dl><dt><span class="term"><code class="literal">name</code></span></dt><dd><div class="changed"><p>a symbolic name for the bound instance.
		  This name is used in the <a href="#header.references.element"><code class="literal">reffile</code></a> element in
		  the referring file's header to identify the bound
		  instance (see <a href="#pml-header" title="5.&#xA0;Header of a PML instance">Section 5, “Header of a PML instance”</a>).
		  The name should match the 
		  <a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-NCName" target="_top"><code class="literal">NCName</code> production</a> of 
		  <a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/" target="_top">Namespaces in XML</a>. (required)
		</p></div></dd><dt><span class="term"><code class="literal">readas</code></span></dt><dd><p>
		  the value <code class="literal">pml</code> instructs the
		  application to read the bound instance as PML
		  (default); the value <code class="literal">trees</code>
		  instructs the application to read the bound instance
		  as a PML instance containing dependency or
		  constituency trees; value <code class="literal">dom</code>
		  instructs the application to read the bound instance
		  as plain XML using the generic Document Object Model
		  (DOM).  (optional)
		</p></dd></dl></div></dd></dl></div><div class="added"><div class="variablelist"><dl><dt><a id="import.element"></a><span class="term"><code class="literal">import</code></span></dt><dd><p>
	    This element instructs an application processing the PML schema to
	    load <a href="#root.element"><code class="literal">root</code></a> and <a href="#type.element"><code class="literal">type</code></a>
	    declarations from an external PML schema file specified in the attribute <code class="literal">schema</code>
	    to the current PML schema.
	    The way in which the declarations are to be combined is
	    described in <a href="#processing" title="7.&#xA0;Processing modular PML schemas">Section 7, “Processing modular PML schemas”</a>.
	  </p><div class="variablelist"><p class="title"><b>Attributes</b></p><dl><dt><span class="term"><code class="literal">type</code></span></dt><dd><p>Name of a specific type to import from the external PML schema file.</p></dd><dt><span class="term"><code class="literal">schema</code></span></dt><dd><p>A filename or URL of the imported external PML schema file.
		If the URL is relative, the URL of the current document is used
		as the base URL. An implementation may additionally provide further means
		of resolving relative URLs, for example, a list of user-defined local paths
		in which it can search for schemas referred to by relative URLs if
		not found relative to the current document.
		</p></dd><dt><span class="term"><code class="literal">revision</code></span></dt><dd><p>Constrains <a href="#revision.element"><code class="literal">revision</code></a> of the imported schema to the specific value.
		  See <a href="#revisions" title="8.&#xA0;Numbering revisions of PML schemas">Section 8, “Numbering revisions of PML schemas”</a> for information on comparing revision numbers.
		  If this attribute is present, then <code class="literal">minimal_revision</code> and
		  <code class="literal">maximal_revision</code> attributes should be absent. (optional)
		</p></dd><dt><span class="term"><code class="literal">minimal_revision</code></span></dt><dd><p>Constrains the <a href="#revision.element"><code class="literal">revision</code></a> of the imported schema to 
		  revision numbers larger or equal to the one specified.
		  See <a href="#revisions" title="8.&#xA0;Numbering revisions of PML schemas">Section 8, “Numbering revisions of PML schemas”</a> for information on comparing revision numbers.
		  If this attribute present,
		  then <code class="literal">revision</code> attribute should be absent. (optional)
		</p></dd><dt><span class="term"><code class="literal">maximal_revision</code></span></dt><dd><p>Constrains <a href="#revision.element"><code class="literal">revision</code></a> of the imported schema to 
		  revisions numbers smaller or equal to the one specified.
		  See <a href="#revisions" title="8.&#xA0;Numbering revisions of PML schemas">Section 8, “Numbering revisions of PML schemas”</a> for information on comparing revision numbers.
		  If this attribute present,
		  then <code class="literal">revision</code> attribute should be absent. (optional)
		</p></dd></dl></div><p><b>Content. </b><code class="literal">EMPTY</code></p></dd><dt><a id="derive.element"></a><span class="term"><code class="literal">derive</code></span></dt><dd><p>
	  This element instructs an application processing the PML
	  schema to create a new type declaration by extending or modifying an
	  existing <em class="firstterm">base declaration</em>
	  specified by the <code class="literal">type</code> attribute.  The
	  newly created type declaration is called the
	  <em class="firstterm">derived declaration</em>.
	  The base declaration may either be one explicitely given
	  by a <a href="#type.element"><code class="literal">type</code></a> element, or 
	  a  previously derived one. The base declaration must declare
	  one of the following types:
	  <a href="#structure.element"><code class="literal">structure</code></a>,
	  <a href="#sequence.element"><code class="literal">sequence</code></a>,
	  <a href="#container.element"><code class="literal">container</code></a>, or
	  <a href="#choice.element"><code class="literal">choice</code></a>.
	</p><p>
	  The element <a href="#derive.element"><code class="literal">derive</code></a> must contain exactly
	  one of the following subelements: <a href="#structure.element"><code class="literal">structure</code></a>, <a href="#sequence.element"><code class="literal">sequence</code></a>, <a href="#choice.element"><code class="literal">choice</code></a>,
	  <a href="#container.element"><code class="literal">container</code></a>, corresponding
	  to the type of the base declaration.
	  In the context of the <a href="#derive.element"><code class="literal">derive</code></a> element,
	  the content and semantics of either of the above listed subelements
	  differs from what is defined elsewhere in this
	  specification in the following way:
	  </p><div class="itemizedlist"><ul type="disc"><li><p>
		each
		<a href="#member.element"><code class="literal">member</code></a>,
		<a href="#element.element"><code class="literal">element</code></a>,
		<a href="#attribute.element"><code class="literal">attribute</code></a>, or
		<a href="#value.element"><code class="literal">value</code></a>
		subelement either replaces a 
		member, element, attribute, or value with the same name (or content in case of <a href="#value.element"><code class="literal">value</code></a>)
		from the base declaration, if such a one exists,
		or adds a new member, element, attribute, or value
		declaration to the derived 
		structure, sequence, container, or choice declaration (respectively).
	      </p><p>
		additionally, the subelement may 
		contain zero or more <a href="#delete.element"><code class="literal">delete</code></a> instructions
		each specifying a member, element, attribute, or value
		of the base declaration to be omitted from the derived declaration.
	      </p></li></ul></div><p>
	</p><p>
	  See <a href="#processing" title="7.&#xA0;Processing modular PML schemas">Section 7, “Processing modular PML schemas”</a> for detailed instructions on processing
	  the <a href="#derive.element"><code class="literal">derive</code></a> instruction.
	</p><div class="variablelist"><p class="title"><b>Attributes</b></p><dl><dt><span class="term"><code class="literal">type</code></span></dt><dd><p>A name of the base type declaration (required).</p></dd><dt><span class="term"><code class="literal">name</code></span></dt><dd><div class="changed"><p>A name for the derived type declaration.
		If not specified, the derived declaration replaces the base declaration
		(this feature should be used with care and, advisably, only 
		for base declarations imported from external PML schemas).
		The name should match the
		<a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-NCName" target="_top"><code class="literal">NCName</code> production</a> of 
            <a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/" target="_top">Namespaces in XML</a>. (optional)
	      </p></div></dd></dl></div><p><b>Content. </b><code class="literal">(<a href="#structure.element">structure</a> | <a href="#sequence.element">sequence</a> | <a href="#choice.element">choice</a> | <a href="#container.element">container</a>)</code></p></dd><dt><a id="delete.element"></a><span class="term"><code class="literal">delete</code></span></dt><dd><p>
	  This instruction can only occur
	  in a <a href="#structure.element"><code class="literal">structure</code></a>, <a href="#sequence.element"><code class="literal">sequence</code></a>, <a href="#choice.element"><code class="literal">choice</code></a>, or
	  <a href="#container.element"><code class="literal">container</code></a> subelement of a 
	  <a href="#derive.element"><code class="literal">derive</code></a> element
	  (and is therefore not included in the specifications of the content 
	  of these individual elements).
	</p><p>The content is a name of a 
	  <a href="#member.element"><code class="literal">member</code></a>,
	  <a href="#element.element"><code class="literal">element</code></a>,
	  <a href="#attribute.element"><code class="literal">attribute</code></a>, or
	  <a href="#value.element"><code class="literal">value</code></a>
	  of a base declaration to be omitted from the derived declaration;
	  see <a href="#derive.element"><code class="literal">derive</code></a> and 
	  <a href="#processing" title="7.&#xA0;Processing modular PML schemas">Section 7, “Processing modular PML schemas”</a> for processing details.
	</p><p><b>Content. </b><code class="literal">#PCDATA</code></p></dd></dl></div></div><div class="variablelist"><dl><dt><a id="root.element"></a><span class="term"><code class="literal">root</code></span></dt><dd><div class="changed"><p>Declaration of
	    the root element of a PML instance.  A PML schema which
	    does not (after possible <a href="#processing" title="7.&#xA0;Processing modular PML schemas">simplification</a>) contain a
	    <a href="#root.element"><code class="literal">root</code></a> declaration does not
	    by itself fully define an application of PML, but may be
	    used as a source of an <a href="#import.element"><code class="literal">import</code></a> instruction in another PML
	    schema.
	</p></div><div class="variablelist"><p class="title"><b>Attributes</b></p><dl><dt><span class="term"><code class="literal">name</code></span></dt><dd><div class="changed"><p>The (local) name of the root element.
		The name should match the
		<a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-NCName" target="_top"><code class="literal">NCName</code> production</a> of 
		  <a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/" target="_top">Namespaces in XML</a> and must be different from <code class="literal">LM</code> and <code class="literal">AM</code>. (required)
	      </p></div></dd><dt><span class="term"><code class="literal">type</code></span></dt><dd><p>declares that the root-element's content is a
		construct of a given named type. This attribute is complementary to
		content, i.e. if this attribute is present, then
                    <a href="#root.element"><code class="literal">root</code></a> must be an
		empty element. The named type this attribute refers to
		must follow the content pattern specified below.
               </p><div class="changed"><p>
		Moreover, if the root element's content is declared as
		a <a href="#container.element"><code class="literal">container</code></a>, then
		the container content type may only be a 
                <a href="#sequence.element"><code class="literal">sequence</code></a>.
              </p></div></dd></dl></div><div class="changed"><p><b>Content. </b><code class="literal">(<a href="#structure.element">structure</a>
	| <a href="#sequence.element">sequence</a> | <a href="#sequence.element">container</a>)</code></p></div></dd><dt><a id="type.element"></a><span class="term"><code class="literal">type</code></span></dt><dd><p>Declaration a named type.  Named types are referred to
	    from other elements using the attribute <a href="#type.element"><code class="literal">type</code></a>. A named type may only be
	    referred from contexts where the actual type represented
	    by the named type is allowed. In other words, 
	    if an element in a PML schema refers to a named type,
	    then the content of the named type definition must be
	    also a valid content for the referring element.
	  </p><div class="variablelist"><p class="title"><b>Attributes</b></p><dl><dt><span class="term"><code class="literal">name</code></span></dt><dd><div class="changed"><p>The name of the new named type.
		The name should match the
		<a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-NCName" target="_top"><code class="literal">NCName</code> production</a> of 
		<a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/" target="_top">Namespaces in XML</a>.  (required)
		</p></div></dd></dl></div><p><b>Content. </b><code class="literal">(<a href="#alt.element">alt</a> | <a href="#list.element">list</a> | <a href="#choice.element">choice</a> | <a href="#constant.element">constant</a> | <a href="#structure.element">structure</a> | <a href="#container.element">container</a> | <a href="#sequence.element">sequence</a> | <a href="#cdata.element">cdata</a>)</code></p></dd><dt><a id="structure.element"></a><span class="term"><code class="literal">structure</code></span></dt><dd><p>Declares a complex type which is a structure
	    with the specified members. Its content consists of one
	    or more <a href="#member.element"><code class="literal">member</code></a>
	    elements defining members of the structure.
	  </p><div class="variablelist"><p class="title"><b>Attributes</b></p><dl><dt><span class="term"><code class="literal">name</code></span></dt><dd><div class="changed"><p>An optional name of the type. This name is not
		  used in the PML schema, but may be used by
		  applications, e.g. when presenting constructs of the
		  type to the user.
		The name should match the
		<a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-NCName" target="_top"><code class="literal">NCName</code> production</a> of 
		<a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/" target="_top">Namespaces in XML</a>.
		  (optional)</p></div></dd><dt><span class="term"><code class="literal">role</code></span></dt><dd><p>The PML role of the constructs of the type (optional)</p></dd></dl></div><p><b>Content. </b><code class="literal">(<a href="#member.element">member</a>)+</code></p></dd><dt><a id="member.element"></a><span class="term"><code class="literal">member</code></span></dt><dd><p>Declares a member of a structure.  The attribute
	    <code class="literal">name</code> defines the name of the
	    member. The type of the member's value is specified either
	    by the content or using the <code class="literal">type</code>
	    attribute.  It is an error if a structure declaration
	    contains two member declarations with the same name.
	  </p><div class="variablelist"><p class="title"><b>Attributes</b></p><dl><dt><span class="term"><code class="literal">name</code></span></dt><dd><div class="changed"><p>Name of the member.
		    The name should match the
		    <a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-NCName" target="_top"><code class="literal">NCName</code> production</a> of 
		  <a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/" target="_top">Namespaces in XML</a> and must be different from <code class="literal">LM</code> and <code class="literal">AM</code>. (required)</p></div></dd><dt><span class="term"><code class="literal">required</code></span></dt><dd><p>value <code class="literal">1</code> declares the 
		  member as required, value <code class="literal">0</code>
		  declares the member as optional (default is 0).
		  Required member must be non-empty.
		</p></dd><dt><span class="term"><code class="literal">role</code></span></dt><dd><p>PML role of the member's value (optional)</p></dd><dt><span class="term"><code class="literal">as_attribute</code></span></dt><dd><p>value <code class="literal">1</code> declares that the
		  member is in XML realized as an attribute of the
		  element realizing the structure. In that case, the
		  value type must be atomic.  Value
		  <code class="literal">0</code> declares that the member is
		  realized as an XML element whose content realizes
		  the value construct.  In the latter case case no
		  restrictions are put on the value type
		  (default is 0)</p></dd><dt><span class="term"><code class="literal">type</code></span></dt><dd><div class="changed"><p>declares that the member is of a given named
		  type.  If this attribute is present then content of
		  the element <a href="#member.element"><code class="literal">member</code></a>
		  should be empty, with the only exception when
		  <code class="literal">role</code> is <a href="#KNIT.pmlrole"><code class="literal">#KNIT</code></a> in which case content
		  should be a <a href="#cdata.element"><code class="literal">cdata</code></a>
		  definition with <a href="#PMLREF.format"><code class="literal">PMLREF</code></a> format and
		  <code class="literal">type</code> should be used to specify the
		  type of the value after knitting).
		</p></div></dd></dl></div><p><b>Content. </b><code class="literal">(<a href="#alt.element">alt</a> | <a href="#list.element">list</a> | <a href="#choice.element">choice</a> | <a href="#constant.element">constant</a> | <a href="#structure.element">structure</a> | <a href="#container.element">container</a> | <a href="#sequence.element">sequence</a> | <a href="#cdata.element">cdata</a>)</code></p></dd><dt><a id="list.element"></a><span class="term"><code class="literal">list</code></span></dt><dd><p>Defines a complex type as a list of constructs of a
	    given type. The content or <code class="literal">type</code> defines
	    the type of the list members.
	  </p><div class="variablelist"><p class="title"><b>Attributes</b></p><dl><dt><span class="term"><code class="literal">ordered</code></span></dt><dd><p>value <code class="literal">1</code> declares an
		    ordered list, value <code class="literal">0</code>
		    declares an unordered list (required)</p></dd><dt><span class="term"><code class="literal">type</code></span></dt><dd><div class="changed"><p>declares that the member constructs are of a
		  given named type.  If this attribute is present then
		  content of the <a href="#list.element"><code class="literal">list</code></a>
		  element should be empty, with the exception when
		  <code class="literal">role</code> is <a href="#KNIT.pmlrole"><code class="literal">#KNIT</code></a> in which case content
		  should be a <a href="#cdata.element"><code class="literal">cdata</code></a> definition
		   with <a href="#PMLREF.format"><code class="literal">PMLREF</code></a> format and
		  <code class="literal">type</code> should be used to specify the
		  type of list members after
		  knitting).
		</p></div></dd><dt><span class="term"><code class="literal">role</code></span></dt><dd><p>PML-role of constructs of the type - currently only roles
		  <a href="#KNIT.pmlrole"><code class="literal">#KNIT</code></a> and <a href="#CHILDNODES.pmlrole"><code class="literal">#CHILDNODES</code></a> may be used with lists (optional)</p></dd></dl></div><p><b>Content. </b><code class="literal">(<a href="#alt.element">alt</a> | <a href="#choice.element">choice</a> | <a href="#constant.element">constant</a> | <a href="#structure.element">structure</a> | <a href="#container.element">container</a> |<a href="#sequence.element">sequence</a> | <a href="#cdata.element">cdata</a>)</code></p></dd><dt><a id="alt.element"></a><span class="term"><code class="literal">alt</code></span></dt><dd><p>
	    Defines a type which is an alternative of constructs of a
	    given type. The content defines a type of the alternative members
	    (unless a named type is specified in the <code class="literal">type</code> attribute).
	  </p><div class="variablelist"><p class="title"><b>Attributes</b></p><dl><dt><span class="term"><code class="literal">type</code></span></dt><dd><p>declares that the constructs contained
		    in the list are of a given named type (complementary to content)</p></dd></dl></div><p><b>Content. </b><code class="literal">(<a href="#list.element">list</a> | <a href="#choice.element">choice</a> | <a href="#constant.element">constant</a> | <a href="#structure.element">structure</a> | <a href="#container.element">container</a> | <a href="#sequence.element">sequence</a> | <a href="#cdata.element">cdata</a>)</code></p></dd><dt><a id="choice.element"></a><span class="term"><code class="literal">choice</code></span></dt><dd><p>Defines an enumerated type with a set of
	    possible values specified in the <a href="#value.element"><code class="literal">value</code></a>
	    sub-elements.</p><p><b>Content. </b><code class="literal">(<a href="#value.element">value</a>)+</code></p></dd><dt><a id="value.element"></a><span class="term"><code class="literal">value</code></span></dt><dd><p>The text content of this element is one of the values
	  of an enumerated type.</p><p><b>Content. </b><code class="literal">PCDATA</code></p></dd><dt><a id="cdata.element"></a><span class="term"><code class="literal">cdata</code></span></dt><dd><p>Defines an atomic type.
            Constructs of atomic types are represented
	    in XML as text or attribute values. The atomic type is
	    further specified using the <code class="literal">format</code>
	    attribute which can have one of the values listed in <a href="#pml-formats" title="3.&#xA0;Atomic data formats">Section 3, “Atomic data formats”</a>.
	  </p><p><b>Content. </b><code class="literal">EMPTY</code></p></dd><dt><a id="constant.element"></a><span class="term"><code class="literal">constant</code></span></dt><dd><p>Defines an atomic type with a constant value specified
	  in the content.</p><p><b>Content. </b><code class="literal">PCDATA</code></p></dd><dt><a id="sequence.element"></a><span class="term"><code class="literal">sequence</code></span></dt><dd><div class="changed"><p>Defines a data type representing
	    ordered sequences of zero or more constituents.
	    Each constituent is either a string of text or a named element
	    whose content data type is uniquely determined by
	    the element's name. The declaration of a sequence
	    </p><div class="itemizedlist"><ul type="disc"><li><p>specifies elements which can occur in the sequence,
		  uniquely mapping element names to data types,
		</p></li><li><p>indicates if text constituents are allowed to occur in the sequence (sequences permitting text constituents are called mixed-content sequences),</p></li><li><p>and, optionally, provides a simple regular-expression-like pattern
		  describing all admissible orderings of constituents (element and interleaved text) in the sequence</p></li></ul></div><p>
	    Two text constituents in a mixed-content sequences should
	    never be adjacent, i.e. there must always be an element
	    occurring between every two text constituents.
	  </p></div><div class="variablelist"><p class="title"><b>Attributes</b></p><dl><dt><span class="term"><code class="literal">role</code></span></dt><dd><p>PML role of constructs of the type (optional)</p></dd><dt><a id="content_pattern.attribute"></a><div class="added"><span class="term"><code class="literal">content_pattern</code></span></div></dt><dd><div class="added"><p>This attribute constraints the order in
		  which the constituents are allowed to appear in the
		  sequence by means of an expression called content
		  pattern (very similar and conceptually equivalent to the grammar of the element content model
		  declaration in DTD and also similar to the syntax used in the productions in this specification).
		</p><p>The content pattern is built on content particles (<code class="literal">cp</code>'s), which consist of constituent specifiers, choice lists of content particles, or sequence lists of content particles. 
The syntax of a content pattern is given by the following grammar production rules:
</p><pre class="programlisting">
pattern      ::= ( choice | seq | cp )

cnst         ::= ( Element-name | '#TEXT' )

cp           ::= ( cnst | '(' choice ')' | '(' seq ')' ) quantifier?

quantifier   ::= ( '?' | '*' | '+' )?

choice       ::= WS? cp ( WS? '|' WS? cp )+ WS?

seq          ::= WS? cp ( WS? ',' WS? cp )* WS?

WS           ::=  (#x20 | #x9 | #xD | #xA)+
</pre><p>
		  where <code class="literal">pattern</code> is the content pattern;
		  a content particle (<code class="literal">cp</code>) represents one or more constituents,
		  which may appear in the sequence on a position in which
		  the content particle appears in the pattern;
		  <code class="literal">Element-name</code> is a name of an element
		  constituent (see <a href="#element.element">element</a>) and represents any element constituent with this name; the string <code class="literal">'#TEXT'</code> represents a text constituent;
		  any of the content particles occurring in a 
		  <a href="#choice.element"><code class="literal">choice</code></a> group may appear
		  in the sequence at a position in which the
		  <a href="#choice.element"><code class="literal">choice</code></a> group appears in the pattern; 
		  content particles occurring in a <code class="literal">seq</code> group
		  must each appear in the sequence in the order
		  in which it is listed in the group;
		  optional <code class="literal">quantifier</code> character 
		  following a content particle governs whether the content it represents may occur one or more (<code class="literal">+</code>), zero or more (<code class="literal">*</code>), or zero or one times (<code class="literal">?</code>). The absence of a quantifier means that the content specified by the content particle must appear exactly once;
		  content particles, brackets, commas, etc. may be optionally separated by white-space
		  (<code class="literal">WS</code>).
		</p><p>A sequence matches a content pattern if and only if there is a path through the content pattern, obeying the sequence, choice, and quantifier operators and matching each constituent in the sequence against a <code class="literal">cnst</code> production (<code class="literal">Element-name</code> or <code class="literal">'#TEXT'</code>). It is an error if the pattern allows two adjacent text constituents.
		</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
		    For compatibility with some SGML based content model implementations, it is advisable (but not enforced) to avoid non-deterministic (1-ambiguous) content patterns such as <code class="literal">(a,b)*,a?</code> (see e.g. Appendix <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#determinism" target="_top">E Deterministic Content Models (Non-Normative)</a> to the <a href="http://www.w3.org/TR/2004/REC-xml-20040204/#determinism" target="_top">XML 1.0 specification</a> and the pointers therein). In particular, a constituent should not match more than one
		    occurrence of a <code class="literal">cnst</code> production in the content pattern.</p></div></div></dd></dl></div><div class="changed"><p><b>Content. </b><code class="literal"><a href="#text.element">text</a>?, (<a href="#element.element">element</a>)+</code></p></div></dd><dt><a id="text.element"></a><div class="added"><span class="term"><code class="literal">text</code></span></div></dt><dd><div class="added"><p>This element can be used at the beginning
	    of the <a href="#sequence.element"><code class="literal">sequence</code></a> element
	    to indicate that the sequence is of mixed-content.
	    In that case, every (maximal) contiguous character content 
	    (including white-space) occurring within the XML element representing 
	    the sequence is treated as a constituent of the sequence.
	  </p></div><p><b>Content. </b>EMPTY</p></dd><dt><a id="element.element"></a><span class="term"><code class="literal">element</code></span></dt><dd><div class="changed"><p>Declares an element constituent of a sequence.
	    The attribute <code class="literal">name</code> specifies its name and
	    either the content or the <code class="literal">type</code> attribute defines the value type.
	    
	    It is an error if a <a href="#sequence.element"><code class="literal">sequence</code></a> declaration contains two elements
	    with the same name.
	  </p></div><div class="variablelist"><p class="title"><b>Attributes</b></p><dl><dt><span class="term"><code class="literal">name</code></span></dt><dd><div class="changed"><p>name of the element. 		The name should match the
		<a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-NCName" target="_top"><code class="literal">NCName</code> production</a> of 
		  <a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/" target="_top">Namespaces in XML</a> and must be different from <code class="literal">LM</code> and <code class="literal">AM</code>. (required)</p></div></dd><dt><span class="term"><code class="literal">role</code></span></dt><dd><p>PML role of the construct (optional)</p></dd><dt><span class="term"><code class="literal">type</code></span></dt><dd><div class="changed"><p>declares that the value is of a given named
		  type. If this attribute is present then <a href="#element.element"><code class="literal">element</code></a> should be empty,
		  with the only exception when <code class="literal">role</code>
		  is <a href="#KNIT.pmlrole"><code class="literal">#KNIT</code></a> in which
		  case content should be a <a href="#cdata.element"><code class="literal">cdata</code></a> definition 
		  with <a href="#PMLREF.format"><code class="literal">PMLREF</code></a> format
		  and <code class="literal">type</code> should be used to specify
		  the value type after knitting).
		</p></div></dd></dl></div><div class="changed"><p><b>Content. </b><code class="literal">(<a href="#alt.element">alt</a> | <a href="#list.element">list</a> | <a href="#choice.element">choice</a> | <a href="#constant.element">constant</a> | <a href="#structure.element">structure</a> | <a href="#container.element">container</a> | <a href="#sequence.element">sequence</a> | <a href="#cdata.element">cdata</a>)</code></p></div></dd><dt><a id="container.element"></a><div class="added"><span class="term"><code class="literal">container</code></span></div></dt><dd><div class="added"><p>
	    Declares a container type. A container consists of a content value accompanied
	    by an annotation provided by a set of name-value pairs with atomic values called attributes.
	    The declaration consists of zero or more 
	    <a href="#attribute.element"><code class="literal">attribute</code></a> declarations, followed
	    by the content type declaration. The content can be of any type except
	    for container and structure. Containers with empty content
	    (indicated by absence of a content type declaration) are permitted.
	  </p></div><div class="added"><div class="variablelist"><p class="title"><b>Attributes</b></p><dl><dt><span class="term"><code class="literal">role</code></span></dt><dd><p>PML role of the construct (optional)</p></dd><dt><span class="term"><code class="literal">type</code></span></dt><dd><p>declares that the content is a
		    construct of a given named type. This attribute
		    is complementary to the part in brackets in the
		    content specification below. That is, if the <code class="literal">type</code>
		    attribute is present, then <a href="#container.element"><code class="literal">container</code></a>
                    can only contain attribute declarations.
                  </p></dd></dl></div></div><div class="added"><p><b>Content. </b><code class="literal"><a href="#attribute.element">attribute</a>* (<a href="#alt.element">alt</a> | <a href="#list.element">list</a> | <a href="#choice.element">choice</a> | <a href="#constant.element">constant</a> | <a href="#sequence.element">sequence</a> | <a href="#cdata.element">cdata</a>)?</code></p></div></dd><dt><a id="attribute.element"></a><span class="term"><code class="literal">attribute</code></span></dt><dd><div class="changed"><p>Defines an attribute of a <a href="#container.element"><code class="literal">container</code></a>. 
	    The content defines the type of attribute's value.</p></div><div class="variablelist"><p class="title"><b>Attributes</b></p><dl><dt><span class="term"><code class="literal">name</code></span></dt><dd><div class="changed"><p>name of the attribute.
		  The name must either match the
		<a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-NCName" target="_top"><code class="literal">NCName</code> production</a> of 
		<a href="http://www.w3.org/TR/1999/REC-xml-names-19990114/" target="_top">Namespaces in XML</a> or be equal to '<code class="literal">xml:id</code>'. 
Note that the latter is particularly useful in combination with the role <code class="literal">#ID</code>, and allows
applications that are not PML-aware to recognize the attribute as an identifier
as described in the <a href="www.w3.org/TR/xml-id/" target="_top">xml:id</a> specification.
(required)</p></div></dd><dt><span class="term"><code class="literal">required</code></span></dt><dd><p>value <code class="literal">1</code> declares the 
		  attribute as required, i.e. one that must be present on its container; value <code class="literal">0</code>
		  declares the attribute as optional (defaults to 0 - optional).
		  Required attribute must be non-empty.
		</p></dd><dt><span class="term"><code class="literal">role</code></span></dt><dd><p>defines a PML role of the attribute (optional)</p></dd><dt><span class="term"><code class="literal">type</code></span></dt><dd><p>defines the type of the attribute value as
		  a given named type. The named type must be atomic. (The <code class="literal">type</code> attribute is complementary to content.)</p></dd></dl></div><p><b>Content. </b><code class="literal">(<a href="#choice.element">choice</a> | <a href="#cdata.element">cdata</a> | <a href="#cdata.element">constant</a>)</code></p></dd></dl></div></div><div class="added"><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="processing"></a>7. Processing modular PML schemas</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#id262877">7.1. Processing <code class="literal">import</code> elements</a></span></dt><dt><span class="section"><a href="#id263440">7.2. Processing <code class="literal">derive</code> elements</a></span></dt></dl></div><p>
      A <em class="firstterm">simplified PML schema</em> is one
      which does not contain any <a href="#import.element"><code class="literal">import</code></a> and <a href="#derive.element"><code class="literal">derive</code></a>.
      Simplified PML schemas are thus self-contained.
    </p><p>
      This section describes how to process a PML schema containing
      <a href="#import.element"><code class="literal">import</code></a> and <a href="#derive.element"><code class="literal">derive</code></a>
      instructions in order to obtain a simplified PML schema
      semantically equivalent to the original PML schema
      (we call two PML schemas semantically equivalent
      if they describe the same class of instances,
      mapping same data to same data types
      and identifying these types with the same PML roles).
    </p><p>
      We describe the process of simplification of a PML schema by
      means of modifications to the original PML schema, although a
      particular implementation might choose a different processing
      strategy. See <a href="#pml-tools" title="10.2.&#xA0;Tools">Section 10.2, “Tools”</a> for a pointer to
      a reference implementation of this process.
    </p><p>
      A PML schema processor must first
      process all <a href="#import.element"><code class="literal">import</code></a> instructions
      in the order in which they appear in the PML schema
      and then process the <a href="#derive.element"><code class="literal">derive</code></a> instructions.
    </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id262877"></a>7.1. Processing <code class="literal">import</code> elements</h3></div></div></div><p>
	We call <em class="firstterm">current schema</em> the PML schema containing the <a href="#import.element"><code class="literal">import</code></a>
	element in turn, and <em class="firstterm">imported schema</em>
	the PML schema referred to by the attribute
	<code class="literal">schema</code> of the <a href="#import.element"><code class="literal">import</code></a>
	element. The processing of the <a href="#import.element"><code class="literal">import</code></a> instruction
	differs depending on the presence of the <code class="literal">type</code> attribute.
      </p><p>
	If the <code class="literal">type</code> attribute is present, the element is processed as follows:
	</p><div class="itemizedlist"><ul type="disc"><li><p>
	      If the current schema contains a <a href="#type.element"><code class="literal">type</code></a> declaration
	      or a <a href="#derive.element"><code class="literal">derive</code></a> instruction
	      whose attribute <code class="literal">name</code> 
	      equals to the value of the
	      <code class="literal">type</code> attribute of the <a href="#import.element"><code class="literal">import</code></a> element, then the processing of the
	      <a href="#import.element"><code class="literal">import</code></a> element stops
	      and it is removed from the current schema
	      (this includes cases when the type declaration was added to the current
	      schema during processing of any preceding <a href="#import.element"><code class="literal">import</code></a> elements).
	    </p></li><li><p>Otherwise, the imported schema is read from the 
	      file specified by an URL (absolute or relative to the location
	      of the file containing the current schema) contained in the <code class="literal">schema</code> attribute
	      of the element <a href="#import.element"><code class="literal">import</code></a>.</p></li><li><p>The imported schema is parsed and 
	      its <a href="#revision.element"><code class="literal">revision</code></a> number
	      is mached against <code class="literal">revision</code> or
	      <code class="literal">minimal_revision</code> and <code class="literal">maximal_revision</code>
	      attributes of the <a href="#import.element"><code class="literal">import</code></a> element (if any of them is present).
	      More specifically, if <code class="literal">revision</code> attribute of <a href="#import.element"><code class="literal">import</code></a>
	      is present then the imported schema revision must be equal to it.
	      If <code class="literal">minimal_revision</code> attribute of <a href="#import.element"><code class="literal">import</code></a>
	      is present then the imported schema revision must be greater or equal to it.
	      If <code class="literal">maximal_revision</code> attribute of <a href="#import.element"><code class="literal">import</code></a>
	      is present then the imported schema revision must be less or equal to it.    
	      It is an error if the revision of the imported schema does not match these constraints.
	      The details of revision numbering and comparison of revision numbers
	      are given in <a href="#revisions" title="8.&#xA0;Numbering revisions of PML schemas">Section 8, “Numbering revisions of PML schemas”</a>.
	    </p></li><li><p>The imported schema is processed according to these instructions
	      into a simplified PML schema. (It is an error if two or more PML schemas refer among
	      themselves via <a href="#import.element"><code class="literal">import</code></a> elements in a way that forms a cycle
	      or if a PML schema refers via an <a href="#import.element"><code class="literal">import</code></a> element to itself).
	    </p></li><li><p>
	      A <a href="#type.element"><code class="literal">type</code></a> declaration
	      whose attribute <code class="literal">name</code> equals to the
	      attribute <code class="literal">type</code> of the <a href="#import.element"><code class="literal">import</code></a> element
	      is located in the imported schema and copied to the current schema.
	      It is an error if such a declaration cannot be found in the imported schema.
	    </p></li><li><p>
	      Every named type referred to 
	      by a <code class="literal">type</code> attribute from any element 
	      occurring within the copied declaration is also copied
	      from the imported schema to the current schema,
	      unless a <a href="#type.element"><code class="literal">type</code></a> declaration 
	      <span class="added"><span> or a <a href="#derive.element"><code class="literal">derive</code></a> instruction</span></span>
	      with the same <code class="literal">name</code>
	      already exists in the current schema.
	      This step is repeated as long as there are 
	      copied type declarations referring to declarations
	      in the imported schema for which there is no <a href="#type.element"><code class="literal">type</code></a> declaration 
	      in the current schema with the same <code class="literal">name</code>
	      (either a copied or an original one). In other words,
	      after copying the first <a href="#type.element"><code class="literal">type</code></a> declaration,
	      other <a href="#type.element"><code class="literal">type</code></a> declarations may be copied
	      to the current schema so that all references to named types
	      are satisfied.
	    </p></li><li><p>
	      Finally, the <a href="#import.element"><code class="literal">import</code></a> element is removed from the current schema.
	    </p></li></ul></div><p>
      </p><p>
	If the attribute <code class="literal">type</code> of the <a href="#import.element"><code class="literal">import</code></a> element
	is absent, the instruction is processed as follows:
	</p><div class="itemizedlist"><ul type="disc"><li><p>The imported schema is read from the 
	      file specified by the <code class="literal">schema</code> attribute
	      of the <a href="#import.element"><code class="literal">import</code></a> element, parsed and processed
	      just as in the prior case.</p></li><li><p>
	      If the current schema does not contain 
	      <a href="#root.element"><code class="literal">root</code></a> declaration
	      and there is a <a href="#root.element"><code class="literal">root</code></a> declaration
	      in the imported schema, it is copied to the current schema.
	    </p></li><li><p>
	      Every <a href="#type.element"><code class="literal">type</code></a> declaration
	      is copied from the imported schema to the current schema,
	      unless there already is a <a href="#type.element"><code class="literal">type</code></a> declaration
	      with the same <code class="literal">name</code> in the current schema.
	    </p></li><li><p>
	      The <a href="#import.element"><code class="literal">import</code></a> element is removed from the current schema.
	    </p></li></ul></div><p>
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id263440"></a>7.2. Processing <code class="literal">derive</code> elements</h3></div></div></div><p>
	The <a href="#derive.element"><code class="literal">derive</code></a> instructions cannot
	be processed if the schema contains any non-processed
	<a href="#import.element"><code class="literal">import</code></a> instructions.
      </p><p>
	The <a href="#derive.element"><code class="literal">derive</code></a> element
	has an attribute <code class="literal">type</code> referring
	to a named <a href="#type.element"><code class="literal">type</code></a> declaration which will be called
	the <em class="firstterm">base declaration</em>.
	It is an error if the PML schema (after all preceding
	<a href="#derive.element"><code class="literal">derive</code></a> instructions have been processed)
	does not contain a corresponding base declaration,
	i.e. a declaration whose attribute <code class="literal">name</code> equals
	to the attribute <code class="literal">type</code> of the 
	<a href="#derive.element"><code class="literal">derive</code></a> element.
      </p><div class="changed"><p>
	If the <a href="#derive.element"><code class="literal">derive</code></a>
	element contains an attribute <code class="literal">name</code>
	specifying a <em class="firstterm">target declaration name</em>,
	the base declaration is copied to the PML schema
	as a new <a href="#type.element"><code class="literal">type</code></a> declaration
	under the target declaration name.
	We refer to this copy as <em class="firstterm">target declaration</em>.
	It is an error if prior to creating the target declaration
	the PML schema already contained
	a named <a href="#type.element"><code class="literal">type</code></a> 
	declaration with the same name.
	If the
	<code class="literal">name</code> attribute 
	of the <a href="#derive.element"><code class="literal">derive</code></a> element
	is absent, the target declaration is the base declaration.
      </p></div><p>
	The <a href="#derive.element"><code class="literal">derive</code></a> element
	and the target declaration must contain the same subelement,
	which is one of
	<a href="#structure.element"><code class="literal">structure</code></a>,
	<a href="#sequence.element"><code class="literal">sequence</code></a>,
	<a href="#container.element"><code class="literal">container</code></a>, or
	<a href="#choice.element"><code class="literal">choice</code></a>.
	We refer to the subelement of the <a href="#derive.element"><code class="literal">derive</code></a>
	element as <em class="firstterm">source</em>
	and to the subelement of the <a href="#type.element"><code class="literal">type</code></a>
	element representing the target declaration as <em class="firstterm">target</em>.
      </p><p>
	For each attribute of the source with a non-empty value
	the corresponding attribute on the target is added or 
	if already present, its value is changed to match the value on the source.
	If an attribute is present on both the
	source and target but its value on the source is empty,
	the attribute on the target is removed from the target element.
	All other attributes of the target are left unchanged.
      </p><p>
	If the source (and hence also the target) is a <a href="#structure.element"><code class="literal">structure</code></a>
	element, all <a href="#member.element"><code class="literal">member</code></a>
	subelements of the source are copied
	into the target, unless
	the target <a href="#structure.element"><code class="literal">structure</code></a> already contains a <a href="#member.element"><code class="literal">member</code></a>
	subelement with the same name, in which case
	the <a href="#member.element"><code class="literal">member</code></a> subelement 
	from the source replaces the corresponding
	subelement of the target <a href="#structure.element"><code class="literal">structure</code></a>.
	Then, for every <a href="#delete.element"><code class="literal">delete</code></a>
	subelement of the source,
	the <a href="#member.element"><code class="literal">member</code></a> subelement
	of the target <a href="#structure.element"><code class="literal">structure</code></a>
	whose <code class="literal">name</code> attribute equals to the content
	of the <a href="#delete.element"><code class="literal">delete</code></a> subelement
	is removed from the target <a href="#structure.element"><code class="literal">structure</code></a>.
	It is an error if the source contains a <a href="#delete.element"><code class="literal">delete</code></a>
	for which there is no matching <a href="#member.element"><code class="literal">member</code></a> subelement
	in the target <a href="#structure.element"><code class="literal">structure</code></a>.
      </p><p>
	The processing of source and target elements which are a <a href="#sequence.element"><code class="literal">sequence</code></a>,
	a <a href="#container.element"><code class="literal">container</code></a>, or a <a href="#choice.element"><code class="literal">choice</code></a>
	is defined analogously, replacing
	in the definition the words <a href="#structure.element"><code class="literal">structure</code></a> and <a href="#member.element"><code class="literal">member</code></a>
	with <a href="#sequence.element"><code class="literal">sequence</code></a> and <a href="#element.element"><code class="literal">element</code></a>,
	<a href="#container.element"><code class="literal">container</code></a> and <a href="#attribute.element"><code class="literal">attribute</code></a>, or
	<a href="#choice.element"><code class="literal">choice</code></a> and <a href="#value.element"><code class="literal">value</code></a>,
	respectively, except that for 
	<a href="#choice.element"><code class="literal">choice</code></a>,
	every <a href="#delete.element"><code class="literal">delete</code></a>
	subelement of the source deletes the <a href="#value.element"><code class="literal">value</code></a> subelement
	of the target <a href="#choice.element"><code class="literal">choice</code></a>
	that has the same content (there is no
	<code class="literal">name</code> attribute for <a href="#value.element"><code class="literal">value</code></a> elements).
      </p><p>
	The <a href="#derive.element"><code class="literal">derive</code></a> element is removed from the PML schema
	after the source has been processed as described above.
      </p></div></div></div><div class="added"><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="revisions"></a>8. Numbering revisions of PML schemas</h2></div></div></div><p>
      For maintenance and modularization purposes it is advisible that
      every revision of a PML schema which adds or modifies type
      declarations is assigned a unique revision number. For this
      purpose, PML provides the element <a href="#revision.element"><code class="literal">revision</code></a> of the PML schema.  A modular
      PML schema using the <a href="#import.element"><code class="literal">import</code></a>
      instruction to import types from another PML schema may specify
      constraints on the revision number of the imported schema. This
      section defines the format for PML schema revision numbers and
      revision number comparison method
      (implying a total order on revision numbers). 
      Consequent revisions of a single PML schema file must be numbered in a non-decreasing
      order.
    </p><p>
      Revision numbers should be strings constisting of one or more interleaved
      non-negative integer numbers and the character '<code class="literal">.</code>',
      starting and ending with a number.
    </p><div class="informalexample"><p>
	For example, <code class="literal">12</code>, <code class="literal">0.2.223</code>,
	and <code class="literal">12.23.1.2.2</code> are all valid revision numbers,
	whereas <code class="literal">.3</code>, <code class="literal">-3</code>,<code class="literal">1.2.</code>,
	or <code class="literal">74..23</code> are not.
      </p></div><p>
      We now describe comparizon of two revision numbers.
      Let 
      <em class="replaceable"><code>R</code></em>=<code class="literal"><em class="replaceable"><code>r</code></em><sub>1</sub>.<em class="replaceable"><code>r</code></em><sub>2</sub>.….<em class="replaceable"><code>r</code></em><sub>n</sub></code> and
      <code class="literal">S=</code><code class="literal"><em class="replaceable"><code>s</code></em><sub>1</sub>.<em class="replaceable"><code>s</code></em><sub>2</sub>.….<em class="replaceable"><code>s</code></em><sub>k</sub></code> be two revision numbers, where
      <code class="literal"><em class="replaceable"><code>r</code></em><sub>i</sub></code>
      (for <code class="literal">i=1,…,n</code>)
      and
      <code class="literal"><em class="replaceable"><code>s</code></em><sub>j</sub></code>
      (for <code class="literal">j=1,…,k</code>) are non-negative integers and let <code class="literal">n</code>
      be less or equal to <code class="literal">k</code>.
      Define <code class="literal"><em class="replaceable"><code>r</code></em><sub>i</sub>=0</code> for every
      <code class="literal">i&gt;n</code>. Then <code class="literal">R=S</code>
      if and only if 
      <code class="literal"><em class="replaceable"><code>r</code></em><sub>i</sub>=<em class="replaceable"><code>s</code></em><sub>i</sub></code>
      for every <code class="literal">i=1,…,k</code>;
      <code class="literal">R&lt;S</code>
      if and only if 
      <code class="literal"><em class="replaceable"><code>r</code></em><sub>1</sub>&lt;<em class="replaceable"><code>s</code></em><sub>1</sub></code>
      or there is some <code class="literal">j&lt;k</code> such that 
      <code class="literal"><em class="replaceable"><code>r</code></em><sub>i</sub>=<em class="replaceable"><code>s</code></em><sub>i</sub></code>
      for every <code class="literal">i=1,…,j</code>
      and 
      <code class="literal"><em class="replaceable"><code>r</code></em><sub>j+1</sub>=<em class="replaceable"><code>s</code></em><sub>j+1</sub></code>;
      otherwise <code class="literal">R&gt;S</code>.
    </p><div class="informalexample"><p>
	For example, <code class="literal">1.0.0=1</code>, <code class="literal">2.1.3.8&lt;2.1.12.8</code>, and
	<code class="literal">2&gt;1.9.8</code>.
      </p></div></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="pml-pmlref"></a>9. References in PML</h2></div></div></div><p>While it is likely that in the future PML will
      offer other kinds of references, such as XPointer,
      currently PML only defines syntax and semantics for simple 
      ID-based references to PML structure, element or sequence 
      constructs occurring either in the same or some other PML instance, and
      to XML elements of non-PML XML documents in general.
      Also, there is no syntax defined yet for references to non-XML
      resources or to constructs without an ID.
    </p><p>
      A reference to a construct occurring within the same PML instance is
      represented by the ID of the referred construct (see more specific
      definition below). A reference to an object occurring
      <span class="emphasis"><em>outside</em></span> the PML instance is represented by a string
      formatted according to <a href="#PMLREF.format"><code class="literal">PMLREF</code></a> format,
      i.e., a string consisting of a pair of identifiers separated by the 
      <code class="literal">#</code> character. The first of the two identifiers
      is an ID
      associated in the header of the PML instance with the system file name or
      URL of the instance containing the referred object. The second of the
      identifiers is a unique ID of the construct (or element) within the PML
      (or XML) instance it occurs in.
    </p><p>
      If the referred construct is a structure,
      then its ID is the value of its
      member with the role  <a href="#ID.pmlrole"><code class="literal">#ID</code></a>.
      If the referred construct is a container,
      then its ID is the value of its
      attribute with the role <a href="#ID.pmlrole"><code class="literal">#ID</code></a>.
      If the referred construct is an XML element in a
      non-PML XML document, then its ID is the value of its
      ID-attribute (e.g. either the attribute <code class="literal">xml:id</code> or
      some other attribute declared as ID in the document's DTD or schema).
    </p><div class="example"><a id="id264425"></a><p class="title"><b>Example 19. Some examples of PML references</b></p><pre class="programlisting">
&lt;document xmlns="http://ufal.mff.cuni.cz/pdt/pml/"&gt;
   &lt;head&gt;
     &lt;schema&gt;
       &lt;!-- embedded schema --&gt;
       &lt;s:pml_schema version="1.1" xmlns:s="http://ufal.mff.cuni.cz/pdt/pml/schema/"&gt;
         &lt;s:root name="document"&gt;
           &lt;s:structure&gt;
	     &lt;s:member name="links"&gt;
               &lt;s:list ordered="1"&gt;
	         &lt;s:cdata format="PMLREF"/&gt;
               &lt;/s:list&gt;
             &lt;/s:member&gt;
	     &lt;s:member name="parts"&gt;
	       &lt;s:list ordered="0"&gt;
	         &lt;s:structure&gt;
                   &lt;s:member name="xml:id" role="#ID" as_attribute="1"&gt;
                     &lt;s:cdata format="ID"/&gt;
                   &lt;/s:member&gt;
		   &lt;s:member name="title"&gt;...&lt;/s:membmer&gt;
		   &lt;s:member name="body"&gt;...&lt;/s:membmer&gt;
                 &lt;/s:container&gt;
               &lt;/s:list&gt;
             &lt;/s:member&gt;
           &lt;/s:structure&gt;
         &lt;/s:root&gt;
       &lt;/s:pml_schema&gt;
     &lt;/schema&gt;
     &lt;references&gt;
       &lt;!-- declare documents we will refer to --&gt;
       &lt;reffile id="p1" href="part_1.xml"/&gt;
       &lt;reffile id="p2" href="part_2.xml"/&gt;
     &lt;/references&gt;
   &lt;/head&gt;
   &lt;links&gt;
     &lt;LM&gt;p1#d1002&lt;LM/&gt; &lt;!-- reference to part with ID "d1002" in document "part_1.xml" --&gt;
     &lt;LM&gt;p2#d2234&lt;LM/&gt; &lt;!-- reference to part with ID "d2234" in document "part_2.xml" --&gt;
     &lt;LM&gt;d3237&lt;LM/&gt; &lt;!-- reference to part with ID "d3237" in this document --&gt;
     &lt;LM&gt;d3664&lt;LM/&gt; &lt;!-- reference to part with ID "d3664" in this document --&gt;
   &lt;/links&gt;
   &lt;parts&gt;
     &lt;LM xml:id="d3237"&gt;
       &lt;title&gt;...&lt;/title&gt;
       &lt;body&gt;...&lt;/body&gt;
     &lt;/LM&gt;
     &lt;LM xml:id="d3664"&gt;
       &lt;title&gt;...&lt;/title&gt;
       &lt;body&gt;...&lt;/body&gt;
     &lt;/LM&gt;
   &lt;/parts&gt;
&lt;/document&gt;

      </pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="pml-recommend"></a>10. Final recommendations</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#pml-layers">10.1. Layers of annotation</a></span></dt><dt><span class="section"><a href="#pml-tools">10.2. Tools</a></span></dt></dl></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="pml-layers"></a>10.1. Layers of annotation</h3></div></div></div><p>PML references are suitable for stacking one layer of linguistic
      annotation upon another. For this purpose, the original text is usually
      transformed to a very simple PML instance that only adds the most
      essential features such as basic tokenization, identifiers of individual
      tokens, etc., providing the basis upon which further annotations could be
      stacked. If it is not possible or desirable to directly include
      tokens from the original text in such a base layer, then a suitable mechanism
      (currently not defined by PML) has to be employed in order to
      carry unambiguous references to the corresponding portions of the original text (regardless of the original
      format).
    </p><p>A specific PML schema is usually defined for each of the annotation
      layers. The relation between annotation layers is typically
      expressed on the instance level using PML references and on the
      PML schema level using the instance binding (PML schema element <a href="#header.references.element"><code class="literal">reference</code></a>).
    </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="pml-tools"></a>10.2. Tools</h3></div></div></div><p>
      The XSLT stylesheet <a href="rewrite:pml2rng.xsl" target="_top">pml2rng.xsl</a>
      transforms a PML schema to the corresponding
      Relax NG schema that can be used for validating
      instances of the PML schema. 
      The resulting Relax NG refers to a portion of Relax NG
      common to all PML applications which is stored in the file
      <a href="rewrite:pml_common.rng" target="_top">pml_common.rng</a>.
    </p><p>
      There are many standard freely available tools that can be used to
      validate an XML document against a Relax NG, such as
      <a href="http://www.thaiopensource.com/relaxng/jing.html" target="_top">jing</a> or
      <a href="http://xmlsoft.org/" target="_top">xmllint</a>.
    </p><p>
      A Perl script <a href="rewrite:pml_simplify" target="_top">pml_simplify</a>
      implements a conversion from a modular PML schema to a simplified PML schema
      described in <a href="#processing" title="7.&#xA0;Processing modular PML schemas">Section 7, “Processing modular PML schemas”</a>.
    </p><p>
      The <a href="rewrite:tred" target="_top">Tree Editor TrEd</a>
      has built-in support for PML representation of dependency and
      constituency trees (see Section <a href="rewrite:tred_manual#pmlbackend" target="_top">PMLBackend</a> in
      <a href="rewrite:tred_manual" target="_top">TrEd User's Manual</a> for details).
    </p><p>PML instances may also be processed using conventional XML-oriented
      tools without direct support for PML. One of them worth
      recommending is <a href="http://xsh.sourceforge.net" target="_top">XSH</a>,
      which is a versatile tool for XML processing.</p></div></div><div class="appendix" lang="en" xml:lang="en"><h2 class="title" style="clear: both"><a id="pml-relaxng"></a>Relax NG for PML schema</h2><p>
      In this appendix we provide a Relax NG schema for PML
      Schema files (it is a listing of the file <a href="rewrite:pml_schema.rng" target="_top"><code class="filename">pml_schema.rng</code></a>).
      Note that this Relax NG schema is rather simplistic and that
      does not currently reflect all constraints implied on the syntax
      of the PML schema file expressed in this document. In particular,
      the Relax NG does not enforce
      constraints on applicability of roles nor the requirement
      that a named type may only be referred to in contexts where
      the actual type represented by the named type is permitted.
    </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"
	xmlns:s="http://ufal.mff.cuni.cz/pdt/pml/schema/"
        xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0"
        xmlns:sch="http://www.ascc.net/xml/schematron"
	datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"&gt;
  &lt;sch:ns prefix="s" uri="http://ufal.mff.cuni.cz/pdt/pml/schema/"/&gt;
  &lt;a:documentation&gt;Grammar for PML Schema (version 1.1 or 1.2)&lt;/a:documentation&gt;
  &lt;start&gt;
    &lt;ref name="pml_schema.root_element"/&gt;
  &lt;/start&gt;
  &lt;define name="pml_schema.root_element"&gt;
    &lt;choice&gt;
      &lt;ref name="pml1.2"/&gt;
      &lt;ref name="pml1.1"/&gt;
    &lt;/choice&gt;
  &lt;/define&gt;
  &lt;define name="pml1.2"&gt;
    &lt;externalRef href="pml_schema_1_2.rng"/&gt;
  &lt;/define&gt;
  &lt;define name="pml1.1"&gt;
    &lt;externalRef href="pml_schema_1_1.rng"/&gt;
  &lt;/define&gt;
&lt;/grammar&gt;
</pre></div><div class="appendix" lang="en" xml:lang="en"><h2 class="title" style="clear: both"><a id="pml-examples"></a>Examples</h2><p>In this appendix we provide some
      simple examples of PML usage. Rather than on practical applicability
      of the schemas that follow, we concentrate on demonstrating the features, 
      definitions and representation of various constructs.
      We also show how PML references work and how annotation layers can
      be stacked one upon another.
    </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id264666"></a>1. Dependency trees</h3></div></div></div><p>The PML schema in
      <a href="#example1_schema" title="Example&#xA0;1.&#xA0;PML schema (example1_schema.xml)">Example 1, “PML schema (<code class="filename">example1_schema.xml</code>)”</a>
      and the instance instance  in
      <a href="#example1" title="Example&#xA0;2.&#xA0;Sample instance with the annotation of the sentence:&#10;&#9;  `John loves Mary. He told her this Friday.'&#10;&#9;  (example1.xml)&#10;&#9;">Example 2, “Sample instance with the annotation of the sentence:
	  `<em class="wordasword">John loves Mary. He told her this Friday.</em>'
	  (<code class="filename">example1.xml</code>)
	”</a>
      show an application of PML to
	a very simple analytical dependency annotation of English sentences. In
	this example, the annotation consists of some meta data (annotator's
	name and a time stamp) and a list of trees. Each tree is represented
	by its root-node. Nodes are structures with two members bearing the
	node-labels (word form and its syntactical function) and two technical
	members (index of the node in the ordering of the tree - represented by
	the attribute <code class="literal">ord</code>, and a list of child-nodes -
	represented by the element <code class="literal">governs</code>). Note that if a
	list of child-nodes has only one member, then this single child-node
	may be directly represented by the <code class="literal">governs</code> element.
	This eliminates the need for an extra <code class="literal">LM</code> bracketing
	element. Note that PML does not actually distinguish between dependency
	trees and constituency trees, but since dependency
	trees are ordered trees and are not necessarily projective, we
	have to employ an extra member <code class="literal">ord</code> with PML-role
	<a href="#ORDER.pmlrole"><code class="literal">#ORDER</code></a> for the tree ordering.
        Because we do not want any linguistic complexity to distract
        the reader's attention from the technical aspects of how data
        are defined and represented in PML, we have chosen two shamelessly simple sentences.
      </p><div class="example"><a id="example1_schema"></a><p class="title"><b>Example 1. PML schema (<a href="examples/example1_schema.xml" target="_top"><code class="filename">example1_schema.xml</code></a>)</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;pml_schema version="1.1"
  xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/"&gt;
  &lt;description&gt;Example of dependency tree annotation&lt;/description&gt;
  &lt;root name="annotation"&gt;
    &lt;structure&gt;
      &lt;member name="meta" type="meta.type"/&gt;
      &lt;member name="trees" role="#TREES" required="1"&gt;
	&lt;list type="node.type" ordered="1"/&gt;
      &lt;/member&gt;
    &lt;/structure&gt;
  &lt;/root&gt;
  &lt;type name="meta.type"&gt;
    &lt;structure&gt;
      &lt;member name="annotator"&gt;&lt;cdata format="any"/&gt;&lt;/member&gt;
      &lt;member name="datetime"&gt;&lt;cdata format="any"/&gt;&lt;/member&gt;
    &lt;/structure&gt;
  &lt;/type&gt;
  &lt;type name="node.type"&gt;
    &lt;structure role="#NODE"&gt;
      &lt;member name="ord" as_attribute="1" required="1" role="#ORDER"&gt;
        &lt;cdata format="nonNegativeInteger"/&gt;
      &lt;/member&gt;
      &lt;member name="func" type="func.type" required="1"/&gt;
      &lt;member name="form" required="1"&gt;
        &lt;cdata format="any"/&gt;
      &lt;/member&gt;
      &lt;member name="governs" role="#CHILDNODES" required="0"&gt;
        &lt;list type="node.type" ordered="0"/&gt;
      &lt;/member&gt;
    &lt;/structure&gt;
  &lt;/type&gt;
  &lt;type name="func.type"&gt;
    &lt;choice&gt;
      &lt;value&gt;Pred&lt;/value&gt;
      &lt;value&gt;Subj&lt;/value&gt;
      &lt;value&gt;Obj&lt;/value&gt;
      &lt;value&gt;Attrib&lt;/value&gt;
      &lt;value&gt;Adv&lt;/value&gt;
    &lt;/choice&gt;
  &lt;/type&gt;
&lt;/pml_schema&gt;
</pre></div><div class="example"><a id="example1"></a><p class="title"><b>Example 2. Sample instance with the annotation of the sentence:
	  `<em class="wordasword">John loves Mary. He told her this Friday.</em>'
	  (<a href="examples/example1.xml" target="_top"><code class="filename">example1.xml</code></a>)
	</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;annotation xmlns="http://ufal.mff.cuni.cz/pdt/pml/"&gt;
  &lt;head&gt;
    &lt;schema href="example1_schema.xml"/&gt;
  &lt;/head&gt;
  &lt;meta&gt;
    &lt;annotator&gt;Jan Novak&lt;/annotator&gt;
    &lt;datetime&gt;Sun May 1 18:56:55 2005&lt;/datetime&gt;
  &lt;/meta&gt;
  &lt;trees&gt;
    &lt;LM ord="2"&gt;
      &lt;func&gt;Pred&lt;/func&gt;
      &lt;form&gt;loves&lt;/form&gt;
      &lt;governs&gt;
        &lt;LM ord="1"&gt;
          &lt;func&gt;Subj&lt;/func&gt;
          &lt;form&gt;John&lt;/form&gt;
        &lt;/LM&gt;
        &lt;LM ord="3"&gt;
          &lt;func&gt;Obj&lt;/func&gt;
          &lt;form&gt;Mary&lt;/form&gt;
        &lt;/LM&gt;
      &lt;/governs&gt;
    &lt;/LM&gt;
    &lt;LM ord="2"&gt;
      &lt;func&gt;Pred&lt;/func&gt;
      &lt;form&gt;told&lt;/form&gt;
      &lt;governs&gt;
        &lt;LM ord="1"&gt;
          &lt;func&gt;Subj&lt;/func&gt;
          &lt;form&gt;He&lt;/form&gt;
        &lt;/LM&gt;
        &lt;LM ord="3"&gt;
          &lt;func&gt;Obj&lt;/func&gt;
          &lt;form&gt;her&lt;/form&gt;
        &lt;/LM&gt;
        &lt;LM ord="5"&gt;
          &lt;func&gt;Adv&lt;/func&gt;
          &lt;form&gt;Friday&lt;/form&gt;
          &lt;governs ord="4"&gt; &lt;!-- ditto --&gt;
            &lt;func&gt;Attrib&lt;/func&gt;
            &lt;form&gt;this&lt;/form&gt;               
          &lt;/governs&gt;
        &lt;/LM&gt;
      &lt;/governs&gt;
    &lt;/LM&gt;
  &lt;/trees&gt;
&lt;/annotation&gt;
</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="pml-example-constituency"></a>2. Constituency trees</h3></div></div></div><p>On two simple (and of course incomplete) PML schema+instance examples,
      (<a href="#example2_schema" title="Example&#xA0;3.&#xA0;PML schema (example2_schema.xml)">Example 3, “PML schema (<code class="filename">example2_schema.xml</code>)”</a> +
      <a href="#example2" title="Example&#xA0;4.&#xA0;Sample instance with annotation of the sentence:&#10;&#9;  `John loves Mary. He told her this Friday.' (example2.xml)">Example 4, “Sample instance with annotation of the sentence:
	  `<em class="wordasword">John loves Mary. He told her this Friday.</em>' (<code class="filename">example2.xml</code>)”</a>
      and
      <a href="#example3_schema" title="Example&#xA0;5.&#xA0;PML schema (example3_schema.xml)">Example 5, “PML schema (<code class="filename">example3_schema.xml</code>)”</a> +
      <a href="#example3" title="Example&#xA0;6.&#xA0;Sample instance (example3.xml)">Example 6, “Sample instance (<code class="filename">example3.xml</code>)”</a>)
      we demonstrate
        how Penn-treebank-like constituency trees might be represented
        in PML. This situation
	differs from the dependency trees in two aspects:
	1) with constituency trees we do not have to consider an
        external ordering of the nodes in the tree,
	2) constituency trees usually distinguish between 
	leaf nodes (terminal nodes) and branching nodes (non-terminal nodes).
	In the first sample we deal with this by
	declaring two node types and using sequences instead of lists
        (as lists would require all members to be of the same type).
	In the second sample we provide a minimalist approach
	taking advantage of the fact that a non-terminal node
	has at most one terminal child, which
	in turn eliminates the need to represent leaf nodes as nodes at all.
	This, in combination with the possibility to reuse element names for
	the actual labels, provides a very compact XML notation very close
	to the labeled-bracket syntax of Penn Treebank.
      </p><div class="example"><a id="example2_schema"></a><p class="title"><b>Example 3. PML schema (<a href="examples/example2_schema.xml" target="_top"><code class="filename">example2_schema.xml</code></a>)</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;pml_schema version="1.1"
  xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/"&gt;
  &lt;description&gt;Example of constituency tree annotation&lt;/description&gt;
  &lt;root name="annotation"&gt;
    &lt;sequence role="#TREES" content_pattern="meta, nt+"&gt;
      &lt;element name="meta" type="meta.type"/&gt;
      &lt;element name="nt" type="nonterminal.type"/&gt;
    &lt;/sequence&gt;
  &lt;/root&gt;
  &lt;type name="meta.type"&gt;
    &lt;structure&gt;
      &lt;member name="annotator"&gt;&lt;cdata format="any"/&gt;&lt;/member&gt;
      &lt;member name="datetime"&gt;&lt;cdata format="any"/&gt;&lt;/member&gt;
    &lt;/structure&gt;
  &lt;/type&gt;
  &lt;type name="nonterminal.type"&gt;
    &lt;container role="#NODE"&gt;
      &lt;attribute name="label" type="label.type"/&gt;
      &lt;sequence role="#CHILDNODES"&gt;
	&lt;element name="nt" type="nonterminal.type"/&gt;
	&lt;element name="form" type="terminal.type"/&gt;
      &lt;/sequence&gt;
    &lt;/container&gt;
  &lt;/type&gt;
  &lt;type name="terminal.type"&gt;
    &lt;container role="#NODE"&gt;
      &lt;cdata format="any"/&gt;
    &lt;/container&gt;
  &lt;/type&gt;
  &lt;type name="label.type"&gt;
    &lt;choice&gt;
      &lt;value&gt;S&lt;/value&gt;
      &lt;value&gt;VP&lt;/value&gt;
      &lt;value&gt;NP&lt;/value&gt;
      &lt;value&gt;PP&lt;/value&gt;
      &lt;value&gt;ADVP&lt;/value&gt;
      &lt;!-- etc. --&gt;
    &lt;/choice&gt;
  &lt;/type&gt;

&lt;/pml_schema&gt;
</pre></div><div class="example"><a id="example2"></a><p class="title"><b>Example 4. Sample instance with annotation of the sentence:
	  `<em class="wordasword">John loves Mary. He told her this Friday.</em>' (<a href="examples/example2.xml" target="_top"><code class="filename">example2.xml</code></a>)</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;annotation xmlns="http://ufal.mff.cuni.cz/pdt/pml/"&gt;
  &lt;head&gt;
    &lt;schema href="example2_schema.xml"/&gt;
  &lt;/head&gt;
  &lt;meta&gt;
    &lt;annotator&gt;John Smith&lt;/annotator&gt;
    &lt;datetime&gt;Sun May 1 18:56:55 2005&lt;/datetime&gt;
  &lt;/meta&gt;
  &lt;nt label="S"&gt;
    &lt;nt label="NP"&gt;
      &lt;form&gt;John&lt;/form&gt;
    &lt;/nt&gt;
    &lt;nt label="VP"&gt;
      &lt;form&gt;loves&lt;/form&gt;
      &lt;nt label="NP"&gt;
        &lt;form&gt;Mary&lt;/form&gt;
      &lt;/nt&gt;
    &lt;/nt&gt;
  &lt;/nt&gt;
  &lt;nt label="S"&gt;
    &lt;nt label="NP"&gt;
      &lt;form&gt;He&lt;/form&gt;
    &lt;/nt&gt;
    &lt;nt label="VP"&gt;
      &lt;form&gt;told&lt;/form&gt;
      &lt;nt label="NP"&gt;&lt;form&gt;her&lt;/form&gt;&lt;/nt&gt;
      &lt;nt label="ADVP"&gt;&lt;form&gt;this Friday&lt;/form&gt;&lt;/nt&gt;
    &lt;/nt&gt;
  &lt;/nt&gt;
&lt;/annotation&gt;
</pre></div><p>For brevity, we will not repeat the 
	<code class="literal">meta</code> element in the second example.
      </p><div class="example"><a id="example3_schema"></a><p class="title"><b>Example 5. PML schema (<a href="examples/example3_schema.xml" target="_top"><code class="filename">example3_schema.xml</code></a>)</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;pml_schema version="1.1" xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/"&gt;
  &lt;description&gt;
    Example of very compact constituency tree annotation
  &lt;/description&gt;
  &lt;root name="annotation"&gt;
    &lt;sequence role="#TREES"&gt;
      &lt;element name="S" type="nonterminal.type"/&gt;
    &lt;/sequence&gt;
  &lt;/root&gt;
  &lt;type name="nonterminal.type"&gt;
    &lt;container role="#NODE"&gt;
      &lt;attribute name="form"&gt;&lt;cdata format="any"/&gt;&lt;/attribute&gt;
      &lt;sequence role="#CHILDNODES"&gt;
	&lt;element name="VP" role="#NODE" type="nonterminal.type"/&gt;
	&lt;element name="NP" role="#NODE" type="nonterminal.type"/&gt;
	&lt;element name="PP" role="#NODE" type="nonterminal.type"/&gt;
	&lt;element name="ADVP" role="#NODE" type="nonterminal.type"/&gt;
	&lt;!-- etc. --&gt;
      &lt;/sequence&gt;
    &lt;/container&gt;
  &lt;/type&gt;
&lt;/pml_schema&gt;
</pre></div><div class="example"><a id="example3"></a><p class="title"><b>Example 6. Sample instance (<a href="examples/example3.xml" target="_top"><code class="filename">example3.xml</code></a>)</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;annotation xmlns="http://ufal.mff.cuni.cz/pdt/pml/"&gt;
  &lt;head&gt;&lt;schema href="example3_schema.xml"/&gt;&lt;/head&gt;
  &lt;S&gt;
    &lt;NP form="John"/&gt;
    &lt;VP form="loves"&gt;
      &lt;NP form="Mary"/&gt;
    &lt;/VP&gt;
  &lt;/S&gt;
  &lt;S&gt;
    &lt;NP form="He"/&gt;
    &lt;VP form="told"&gt;
      &lt;NP form="her"/&gt;
      &lt;ADVP form="this Friday"/&gt;
    &lt;/VP&gt;
  &lt;/S&gt;
&lt;/annotation&gt;
</pre></div><p>
	Note that once the labels of non-terminals coincide with the names of elements
	representing nodes, we could apply further restrictions on
	the nesting directly in the PML schema. For example, it would be very easy to 
	incorporate some grammar rules (such as that
	<code class="literal">ADVP</code> can only occur within <code class="literal">VP</code>, etc.).
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id265018"></a>3. Internal references</h3></div></div></div><p>To demonstrate cross-referencing in a PML instance
	we define two  simple PML schemas
	(<a href="#example4_schema" title="Example&#xA0;7.&#xA0;PML schema (example4_schema.xml)">Example 7, “PML schema (<code class="filename">example4_schema.xml</code>)”</a> and
	<a href="#example5_schema" title="Example&#xA0;9.&#xA0;PML schema (example5_schema.xml)">Example 9, “PML schema (<code class="filename">example5_schema.xml</code>)”</a>)
	for representing arbitrary
	graph with both labeled nodes. In the first schema, we
	represent the graph by a list of its vertices and 
	a list of its edges. With the second schema the same
	graph is represented by a list of structures for nodes consisting
	of a label and a  a list of pointers to the nodes connected
        with the current node by an edge.
      </p><div class="example"><a id="example4_schema"></a><p class="title"><b>Example 7. PML schema (<a href="examples/example4_schema.xml" target="_top"><code class="filename">example4_schema.xml</code></a>)</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;pml_schema version="1.1" xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/"&gt;
  &lt;description&gt;An oriented graph&lt;/description&gt;
  &lt;root name="graph"&gt;
    &lt;structure&gt;
      &lt;member name="verteces"&gt;
        &lt;list ordered="0"&gt;
          &lt;structure&gt;
            &lt;member name="id" as_attribute="1" required="1" role="#ID"&gt;
              &lt;cdata format="ID"/&gt;
            &lt;/member&gt;
            &lt;member name="label" required="1"&gt;
              &lt;cdata format="any"/&gt;
            &lt;/member&gt;
          &lt;/structure&gt;
        &lt;/list&gt;
      &lt;/member&gt;
      &lt;member name="edges"&gt;
        &lt;list ordered="0"&gt;
          &lt;structure&gt;
            &lt;member name="from.rf" required="1" as_attribute="1"&gt;
              &lt;cdata format="PMLREF"/&gt;
            &lt;/member&gt;
            &lt;member name="to.rf" required="1" as_attribute="1"&gt;
              &lt;cdata format="PMLREF"/&gt;
            &lt;/member&gt;
          &lt;/structure&gt;
        &lt;/list&gt;
      &lt;/member&gt;
    &lt;/structure&gt;    
  &lt;/root&gt;
&lt;/pml_schema&gt;
</pre></div><div class="example"><a id="example4"></a><p class="title"><b>Example 8. Sample instance (<a href="examples/example4.xml" target="_top"><code class="filename">example4.xml</code></a>)</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;graph xmlns="http://ufal.mff.cuni.cz/pdt/pml/"&gt;
  &lt;head&gt;&lt;schema href="example4_schema.xml"/&gt;&lt;/head&gt;
  &lt;verteces&gt;
    &lt;LM id="v1"&gt;&lt;label&gt;A&lt;/label&gt;&lt;/LM&gt;
    &lt;LM id="v2"&gt;&lt;label&gt;B&lt;/label&gt;&lt;/LM&gt;
    &lt;LM id="v3"&gt;&lt;label&gt;A&lt;/label&gt;&lt;/LM&gt;
    &lt;LM id="v4"&gt;&lt;label&gt;C&lt;/label&gt;&lt;/LM&gt;
    &lt;LM id="v5"&gt;&lt;label&gt;D&lt;/label&gt;&lt;/LM&gt;
  &lt;/verteces&gt;
  &lt;edges&gt;
    &lt;LM from.rf="v1" to.rf="v2"/&gt;
    &lt;LM from.rf="v1" to.rf="v3"/&gt;
    &lt;LM from.rf="v2" to.rf="v4"/&gt;
    &lt;LM from.rf="v3" to.rf="v4"/&gt;
    &lt;LM from.rf="v4" to.rf="v1"/&gt;
  &lt;/edges&gt;
&lt;/graph&gt;
</pre></div><div class="example"><a id="example5_schema"></a><p class="title"><b>Example 9. PML schema (<a href="examples/example5_schema.xml" target="_top"><code class="filename">example5_schema.xml</code></a>)</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;pml_schema version="1.1" xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/"&gt;
  &lt;description&gt;An oriented graph&lt;/description&gt;
  &lt;root name="graph"&gt;
    &lt;structure&gt;
      &lt;member name="body" required="1"&gt;
	&lt;list ordered="0"&gt;
	  &lt;structure&gt;
	    &lt;member name="id" as_attribute="1" 
	      required="1" role="#ID"&gt;
	      &lt;cdata format="ID"/&gt;
	    &lt;/member&gt;
	    &lt;member name="label" required="1"&gt;
	      &lt;cdata format="any"/&gt;
	    &lt;/member&gt;
	    &lt;member name="edges.rf"&gt;
	      &lt;list ordered="0"&gt;
		&lt;cdata format="PMLREF"/&gt;
	      &lt;/list&gt;
	    &lt;/member&gt;
	  &lt;/structure&gt;
	&lt;/list&gt;
      &lt;/member&gt;
    &lt;/structure&gt;
  &lt;/root&gt;
&lt;/pml_schema&gt;
</pre></div><div class="example"><a id="example5"></a><p class="title"><b>Example 10. Sample instance (<a href="examples/example5.xml" target="_top"><code class="filename">example5.xml</code></a>)</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;graph xmlns="http://ufal.mff.cuni.cz/pdt/pml/"&gt;
  &lt;head&gt;&lt;schema href="example5_schema.xml"/&gt;&lt;/head&gt;
  &lt;body&gt;
    &lt;LM id="v1"&gt;
      &lt;label&gt;A&lt;/label&gt;
      &lt;edges.rf&gt;
	&lt;LM&gt;v2&lt;/LM&gt;
	&lt;LM&gt;v3&lt;/LM&gt;
      &lt;/edges.rf&gt;
    &lt;/LM&gt;
    &lt;LM id="v2"&gt;
      &lt;label&gt;B&lt;/label&gt;
      &lt;edges.rf&gt;v4&lt;/edges.rf&gt;
    &lt;/LM&gt;
    &lt;LM id="v3"&gt;
      &lt;label&gt;A&lt;/label&gt;
      &lt;edges.rf&gt;v4&lt;/edges.rf&gt;
    &lt;/LM&gt;
    &lt;LM id="v4"&gt;
      &lt;label&gt;C&lt;/label&gt;
      &lt;edges.rf&gt;v1&lt;/edges.rf&gt;
    &lt;/LM&gt;
    &lt;LM id="v5"&gt;
      &lt;label&gt;D&lt;/label&gt;
    &lt;/LM&gt;
  &lt;/body&gt;
&lt;/graph&gt;
</pre></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id265183"></a>4. External references</h3></div></div></div><p>
	In this example we define PML schemas for two annotation layers. 
	The first layer represents the tokenized text with
	the sentence-boundary markup. The second layer is a constituency-tree annotation of the
	sentences on the first (lower) layer. This constituency annotation is similar to the samples 
	<a href="#pml-example-constituency" title="2.&#xA0;Constituency trees">Section 2, “Constituency trees”</a>, but this time the terminals
	contain references to the tokenized text.
      </p><p>The schema in <a href="#example6_schema" title="Example&#xA0;11.&#xA0;PML schema (example6_schema.xml)">Example 11, “PML schema (<code class="filename">example6_schema.xml</code>)”</a> and the instance
      in <a href="#example6" title="Example&#xA0;12.&#xA0;Sample instance (example6.xml)">Example 12, “Sample instance (<code class="filename">example6.xml</code>)”</a>
      show a tokenization layer.
      </p><div class="example"><a id="example6_schema"></a><p class="title"><b>Example 11. PML schema (<a href="examples/example6_schema.xml" target="_top"><code class="filename">example6_schema.xml</code></a>)</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;pml_schema version="1.1" xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/"&gt;
  &lt;revision&gt;0.2&lt;/revision&gt;
  &lt;description&gt;Example of tokenization layer&lt;/description&gt;
  &lt;root name="tokenization"&gt;
    &lt;structure&gt;
      &lt;member name="sentences"&gt;
	&lt;list ordered="1" type="sentence.type"/&gt;
      &lt;/member&gt;
    &lt;/structure&gt;
  &lt;/root&gt;
  &lt;type name="sentence.type"&gt;
    &lt;structure&gt;
      &lt;member name="id" role="#ID" type="ID.type"
	required="1" as_attribute="1"/&gt;
      &lt;member name="tokens"&gt; &lt;!-- words (tokens) --&gt;
        &lt;sequence&gt;
          &lt;element name="w" type="w.type"/&gt;
        &lt;/sequence&gt;
      &lt;/member&gt;
    &lt;/structure&gt;
  &lt;/type&gt;
  &lt;type name="w.type"&gt;
    &lt;container&gt;
      &lt;attribute name="id" role="#ID" type="ID.type"
	required="1"/&gt;
      &lt;cdata format="any"/&gt;
    &lt;/container&gt;
  &lt;/type&gt;
  &lt;type name="ID.type"&gt;
    &lt;cdata format="ID"/&gt;
  &lt;/type&gt;
&lt;/pml_schema&gt;
</pre></div><div class="example"><a id="example6"></a><p class="title"><b>Example 12. Sample instance (<a href="examples/example6.xml" target="_top"><code class="filename">example6.xml</code></a>)</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;tokenization xmlns="http://ufal.mff.cuni.cz/pdt/pml/"&gt;
  &lt;head&gt;
    &lt;schema href="example6_schema.xml"/&gt;
  &lt;/head&gt;
  &lt;sentences&gt;
    &lt;LM id="s1"&gt;
      &lt;tokens&gt;
        &lt;w id="s1w1"&gt;John&lt;/w&gt;
        &lt;w id="s1w2"&gt;loves&lt;/w&gt;
        &lt;w id="s1w3"&gt;Mary&lt;/w&gt;
        &lt;w id="s1w4"&gt;.&lt;/w&gt;
      &lt;/tokens&gt;
    &lt;/LM&gt;
    &lt;LM id="s2"&gt;
      &lt;tokens&gt;
        &lt;w id="s2w1"&gt;He&lt;/w&gt;
        &lt;w id="s2w2"&gt;told&lt;/w&gt;
        &lt;w id="s2w3"&gt;her&lt;/w&gt;
        &lt;w id="s2w4"&gt;this&lt;/w&gt;
        &lt;w id="s2w5"&gt;Friday&lt;/w&gt;
        &lt;w id="s2w6"&gt;.&lt;/w&gt;
      &lt;/tokens&gt;
    &lt;/LM&gt;
  &lt;/sentences&gt;
&lt;/tokenization&gt;
</pre></div><p>The schema and instance in <a href="#example7_schema" title="Example&#xA0;13.&#xA0;PML schema (example7_schema.xml)">Example 13, “PML schema (<code class="filename">example7_schema.xml</code>)”</a> and
      <a href="#example7" title="Example&#xA0;14.&#xA0;Sample instance (example7.xml)">Example 14, “Sample instance (<code class="filename">example7.xml</code>)”</a>
      show an annotation
	layer stacked over the previously defined tokenization layer.
	The relation between units on these layers, represented
	by PML references from the annotation layer to the tokenization layer,
	may in general be N to M. The references to the tokenization
	layer have role <a href="#KNIT.pmlrole"><code class="literal">#KNIT</code></a>, which indicates
	that applications may replace the member <code class="literal">w.rf</code>
	containing the list of references with the corresponding
	object from the lower layer (i.e. the <code class="literal">w</code> element).
      </p><div class="example"><a id="example7_schema"></a><p class="title"><b>Example 13. PML schema (<a href="examples/example7_schema.xml" target="_top"><code class="filename">example7_schema.xml</code></a>)</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;pml_schema version="1.1" xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/"&gt;
  &lt;description&gt;
    Example of tree annotation over a tokenization layer
  &lt;/description&gt;
  &lt;reference name="tokenization" readas="dom"/&gt;
  &lt;root name="annotation"&gt;
    &lt;sequence role="#TREES"&gt;
      &lt;element name="S"&gt;
	&lt;container role="#NODE"&gt;
	  &lt;attribute name="sentence.rf"&gt;
	    &lt;cdata format="PMLREF"/&gt;
	  &lt;/attribute&gt;
	  &lt;list ordered="1" role="#CHILDNODES" type="node.type"/&gt;
	&lt;/container&gt;
      &lt;/element&gt;
    &lt;/sequence&gt;
  &lt;/root&gt;
  &lt;type name="node.type"&gt;
    &lt;structure role="#NODE"&gt;
      &lt;member as_attribute="1" name="label"&gt;
        &lt;choice&gt;
          &lt;value&gt;S&lt;/value&gt;
          &lt;value&gt;VP&lt;/value&gt;
          &lt;value&gt;NP&lt;/value&gt;
          &lt;value&gt;PP&lt;/value&gt;
          &lt;value&gt;ADVP&lt;/value&gt;
          &lt;!-- etc. --&gt;
        &lt;/choice&gt;
      &lt;/member&gt;
      &lt;member name="w.rf"&gt;
	&lt;list ordered="0" role="#KNIT" type="w.type"&gt;
	  &lt;cdata format="PMLREF"/&gt;
	&lt;/list&gt;
      &lt;/member&gt;
      &lt;member name="constituents" role="#CHILDNODES"&gt;
        &lt;list ordered="1" type="node.type"/&gt;
      &lt;/member&gt;
    &lt;/structure&gt;
  &lt;/type&gt;
  &lt;type name="w.type"&gt;
    &lt;container&gt;
      &lt;attribute name="id" role="#ID" required="1"&gt;
        &lt;cdata format="ID"/&gt;
      &lt;/attribute&gt;
      &lt;cdata format="any"/&gt;
    &lt;/container&gt;
  &lt;/type&gt;
&lt;/pml_schema&gt;
</pre></div><div class="example"><a id="example7"></a><p class="title"><b>Example 14. Sample instance (<a href="examples/example7.xml" target="_top"><code class="filename">example7.xml</code></a>)</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;annotation xmlns="http://ufal.mff.cuni.cz/pdt/pml/"&gt;
  &lt;head&gt;
    &lt;schema href="example7_schema.xml"/&gt;
    &lt;references&gt;
      &lt;reffile name="tokenization" id="t" href="example6.xml"/&gt;
    &lt;/references&gt;
  &lt;/head&gt;
  &lt;S sentence.rf="s1"&gt;
    &lt;LM label="NP"&gt;&lt;w.rf&gt;t#s1w1&lt;/w.rf&gt;&lt;/LM&gt;
    &lt;LM label="VP"&gt;
      &lt;w.rf&gt;t#s1w2&lt;/w.rf&gt;
      &lt;constituents label="NP"&gt;
        &lt;w.rf&gt;t#s1w3&lt;/w.rf&gt;
      &lt;/constituents&gt;
    &lt;/LM&gt;
  &lt;/S&gt;
  &lt;S sentence.rf="s2"&gt;
    &lt;LM label="NP"&gt;&lt;w.rf&gt;t#s2w1&lt;/w.rf&gt;&lt;/LM&gt;
    &lt;LM label="VP"&gt;
      &lt;w.rf&gt;t#s2w2&lt;/w.rf&gt;
      &lt;constituents&gt;
        &lt;LM label="NP"&gt;&lt;w.rf&gt;t#s2w3&lt;/w.rf&gt;&lt;/LM&gt;
        &lt;LM label="ADVP"&gt;
          &lt;w.rf&gt;
            &lt;LM&gt;t#s2w4&lt;/LM&gt;
            &lt;LM&gt;t#s2w5&lt;/LM&gt;
          &lt;/w.rf&gt;
        &lt;/LM&gt;
      &lt;/constituents&gt;
    &lt;/LM&gt;
  &lt;/S&gt;
&lt;/annotation&gt;
</pre></div><p>After knitting is applied on PML references in
	<code class="literal">w.rf</code>, the instance appears to the application
	as in <a href="#example7_knit" title="Example&#xA0;15.&#xA0;Sample instance after knitting (example7_knit.xml)">Example 15, “Sample instance after knitting (<code class="filename">example7_knit.xml</code>)”</a>.
      </p><div class="example"><a id="example7_knit"></a><p class="title"><b>Example 15. Sample instance after knitting (<a href="examples/example7_knit.xml" target="_top"><code class="filename">example7_knit.xml</code></a>)</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;annotation xmlns="http://ufal.mff.cuni.cz/pdt/pml/"&gt;
  &lt;head&gt;
    &lt;schema&gt;
      &lt;s:pml_schema xmlns:s="http://ufal.mff.cuni.cz/pdt/pml/schema/" version="1.1"&gt;
	&lt;s:import schema="example7_schema.xml"/&gt;
	&lt;s:derive type="node.type"&gt;
	  &lt;s:structure&gt;
	    &lt;s:member name="w"&gt;&lt;s:list ordered="0" type="w.type"/&gt;&lt;/s:member&gt;
	    &lt;s:delete&gt;w.rf&lt;/s:delete&gt;
	  &lt;/s:structure&gt;
	&lt;/s:derive&gt;
      &lt;/s:pml_schema&gt;
    &lt;/schema&gt;
    &lt;references&gt;
      &lt;reffile name="tokenization" id="t" href="example6.xml"/&gt;
    &lt;/references&gt;
  &lt;/head&gt;
  &lt;S sentence.rf="s1"&gt;
    &lt;LM label="NP"&gt;&lt;w id="s1w1"&gt;John&lt;/w&gt;&lt;/LM&gt;
    &lt;LM label="VP"&gt;
      &lt;w id="s1w2"&gt;loves&lt;/w&gt;
      &lt;constituents label="NP"&gt;
        &lt;w id="s1w3"&gt;Mary&lt;/w&gt;
      &lt;/constituents&gt;
    &lt;/LM&gt;
  &lt;/S&gt;
  &lt;S sentence.rf="s2"&gt;
    &lt;LM label="NP"&gt;&lt;w id="s2w1"&gt;He&lt;/w&gt;&lt;/LM&gt;
    &lt;LM label="VP"&gt;
      &lt;w id="s2w2"&gt;told&lt;/w&gt;
      &lt;constituents&gt;
        &lt;LM label="NP"&gt;&lt;w id="s2w3"&gt;her&lt;/w&gt;&lt;/LM&gt;
        &lt;LM label="ADVP"&gt;
          &lt;w&gt;
            &lt;LM id="s2w4"&gt;this&lt;/LM&gt;
            &lt;LM id="s2w5"&gt;Friday&lt;/LM&gt;
          &lt;/w&gt;
        &lt;/LM&gt;
      &lt;/constituents&gt;
    &lt;/LM&gt;
  &lt;/S&gt;
&lt;/annotation&gt;
</pre></div></div><div class="added"><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id265472"></a>5. Modular schemas</h3></div></div></div><p>
	In the last schema example <code class="filename">example7_schema.xml</code>,
	we have repeated the type <code class="literal">w.type</code> from
	<code class="filename">example6_schema.xml</code>.  In real-world cases,
	copy-paste repetitions lead to many maintainability issues and
	are not a good practice.  Starting from version 1.1, PML 
	provides support for modularization of PML schemas
	via <a href="#import.element"><code class="literal">import</code></a> and <a href="#derive.element"><code class="literal">derive</code></a>
	instructions.  Here is how <code class="filename">example7_schema.xml</code>
	schema could be rewritten using these features:
      </p><div class="example"><a id="example8_schema"></a><p class="title"><b>Example 16. Modular version of the schema <a href="examples/example7_schema.xml" target="_top"><code class="filename">example7_schema.xml</code></a> (<a href="examples/example8_schema.xml" target="_top"><code class="filename">example8_schema.xml</code></a>).</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;pml_schema version="1.1" xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/"&gt;
  &lt;revision&gt;0.7&lt;/revision&gt;
  &lt;description&gt;
    Example of tree annotation over a tokenization layer
  &lt;/description&gt;
  &lt;reference name="tokenization" readas="dom"/&gt;

  &lt;import type="w.type" schema="example6_schema.xml" revision="0.2"/&gt;

  &lt;!-- after DOM-knitting, #ID attribute contains a PMLREF --&gt;
  &lt;derive type="w.type"&gt;
    &lt;container&gt;
      &lt;attribute name="id" role="#ID" required="1"&gt;
	&lt;cdata format="PMLREF"/&gt;
      &lt;/attribute&gt;
    &lt;/container&gt;
  &lt;/derive&gt;

  &lt;root name="annotation" type="annotation.type"/&gt;

  &lt;type name="annotation.type"&gt;
    &lt;sequence role="#TREES"&gt;
      &lt;element name="S" type="S.type"/&gt;
    &lt;/sequence&gt;
  &lt;/type&gt;
  &lt;type name="S.type"&gt;
    &lt;container role="#NODE"&gt;
      &lt;attribute name="sentence.rf"&gt;
	&lt;cdata format="PMLREF"/&gt;
      &lt;/attribute&gt;
      &lt;list ordered="1" role="#CHILDNODES" type="node.type"/&gt;
    &lt;/container&gt;
  &lt;/type&gt;
  &lt;type name="node.type"&gt;
    &lt;structure role="#NODE"&gt;
      &lt;member as_attribute="1" name="label" type="label.type"/&gt;
      &lt;member name="w.rf"&gt;
        &lt;list ordered="0" role="#KNIT" type="w.type"&gt;
          &lt;cdata format="PMLREF"/&gt;
        &lt;/list&gt;
      &lt;/member&gt;
      &lt;member name="constituents" role="#CHILDNODES"&gt;
        &lt;list ordered="1" type="node.type"/&gt;
      &lt;/member&gt;
    &lt;/structure&gt;
  &lt;/type&gt;
  &lt;type name="label.type"&gt;
    &lt;choice&gt;
      &lt;value&gt;S&lt;/value&gt;
      &lt;value&gt;VP&lt;/value&gt;
      &lt;value&gt;NP&lt;/value&gt;
      &lt;value&gt;PP&lt;/value&gt;
      &lt;value&gt;ADVP&lt;/value&gt;
      &lt;!-- etc. --&gt;
    &lt;/choice&gt;
  &lt;/type&gt;
&lt;/pml_schema&gt;
</pre></div><p>
	The modularity allows for extending the imported schema.
	<a href="#example9_schema" title="Example&#xA0;17.&#xA0;Extending PML schemas (example9_schema.xml).">Example 17, “Extending PML schemas (<code class="filename">example9_schema.xml</code>).”</a>
	presents a PML schema based
	on <code class="filename">example8_schema.xml</code>
	but largely extended. It also borrows
	a single type from <code class="filename">example1_schema.xml</code>.
      </p><div class="example"><a id="example9_schema"></a><p class="title"><b>Example 17. Extending PML schemas (<a href="examples/example9_schema.xml" target="_top"><code class="filename">example9_schema.xml</code></a>).</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;pml_schema version="1.1" xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/"&gt;
  &lt;revision&gt;0.1&lt;/revision&gt;
  &lt;description&gt;
    Extended example of tree annotation over a tokenization layer
  &lt;/description&gt;
  &lt;reference name="tokenization" readas="dom"/&gt;

  &lt;import schema="example8_schema.xml" 
          minimal_revision="0.4"
          maximal_revision="1.0"/&gt;
  &lt;import schema="example1_schema.xml" type="meta.type"/&gt;

  &lt;derive type="annotation.type"&gt;
    &lt;sequence content_pattern="meta, S+"&gt;
      &lt;element name="meta" type="newmeta.type"/&gt;
    &lt;/sequence&gt;
  &lt;/derive&gt;
  &lt;derive type="S.type"&gt;
    &lt;container&gt;
      &lt;attribute name="annotators_comment"&gt;
        &lt;cdata format="any"/&gt;
      &lt;/attribute&gt;
    &lt;/container&gt;
  &lt;/derive&gt;
  &lt;derive type="meta.type" name="changes.type"&gt;
    &lt;structure&gt;
      &lt;member name="id" role="#ID" as_attribute="1" required="1"&gt;
        &lt;cdata format="ID"/&gt;
      &lt;/member&gt;
      &lt;member name="desc"&gt;&lt;cdata format="any"/&gt;&lt;/member&gt;
    &lt;/structure&gt;
  &lt;/derive&gt;
  &lt;derive type="label.type"&gt;
    &lt;choice&gt;
      &lt;value&gt;SDECL&lt;/value&gt;
      &lt;value&gt;SIMP&lt;/value&gt;
      &lt;value&gt;SQUEST&lt;/value&gt;
      &lt;delete&gt;S&lt;/delete&gt;
    &lt;/choice&gt;
  &lt;/derive&gt;
  &lt;type name="newmeta.type"&gt;
    &lt;structure&gt;
      &lt;member name="lang"&gt;&lt;cdata format="any"/&gt;&lt;/member&gt;
      &lt;member name="changes"&gt;&lt;list type="changes.type" ordered="1"/&gt;&lt;/member&gt;
    &lt;/structure&gt;
  &lt;/type&gt;
&lt;/pml_schema&gt;
</pre></div><p>
	Modular PML schemas can be converted back to non-modular,
	simplified, PML schemas for easier processing. The 
	schema in <a href="#example10_schema" title="Example&#xA0;18.&#xA0;Extending PML schemas (example10_schema.xml).">Example 18, “Extending PML schemas (<code class="filename">example10_schema.xml</code>).”</a>
	is the simplified version
	of <code class="filename">example9_schema.xml</code>,
	automatically generated
	by the tool <code class="literal">pml_simplify</code>,
	mentioned in <a href="#pml-tools" title="10.2.&#xA0;Tools">Section 10.2, “Tools”</a>.
      </p><div class="example"><a id="example10_schema"></a><p class="title"><b>Example 18. Extending PML schemas (<a href="examples/example10_schema.xml" target="_top"><code class="filename">example10_schema.xml</code></a>).</b></p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;!--
  Created by pml_simplify on Sun Mar 14 10:23:16 2010
  Command-line: pml_simlify examples/example9_schema.xml
--&gt;
&lt;pml_schema xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/" version="1.1"&gt;
  &lt;revision&gt;0.1&lt;/revision&gt;
  &lt;description&gt;
    Extended example of tree annotation over a tokenization layer
  &lt;/description&gt;
  &lt;reference name="tokenization" readas="dom"/&gt;
  &lt;!--  ============ import schema="example8_schema.xml" ============  --&gt;
  &lt;root name="annotation" type="annotation.type"/&gt;
  &lt;type name="w.type"&gt;
    &lt;container&gt;
      &lt;attribute name="id" role="#ID" required="1"&gt;
        &lt;cdata format="PMLREF"/&gt;
      &lt;/attribute&gt;
      &lt;cdata format="any"/&gt;
    &lt;/container&gt;
  &lt;/type&gt;
  &lt;type name="ID.type"&gt;
    &lt;cdata format="ID"/&gt;
  &lt;/type&gt;
  &lt;!--  ============ derived from annotation.type ============  --&gt;
  &lt;type name="annotation.type"&gt;
    &lt;sequence role="#TREES" content_pattern="meta, S+"&gt;
      &lt;element name="S" type="S.type"/&gt;
      &lt;element name="meta" type="newmeta.type"/&gt;
    &lt;/sequence&gt;
  &lt;/type&gt;
  &lt;!--  ============ derived from S.type ============  --&gt;
  &lt;type name="S.type"&gt;
    &lt;container role="#NODE"&gt;
      &lt;attribute name="annotators_comment"&gt;
        &lt;cdata format="any"/&gt;
      &lt;/attribute&gt;
      &lt;attribute name="sentence.rf"&gt;
        &lt;cdata format="PMLREF"/&gt;
      &lt;/attribute&gt;
      &lt;list ordered="1" role="#CHILDNODES" type="node.type"/&gt;
    &lt;/container&gt;
  &lt;/type&gt;
  &lt;type name="node.type"&gt;
    &lt;structure role="#NODE"&gt;
      &lt;member as_attribute="1" name="label" type="label.type"/&gt;
      &lt;member name="w.rf"&gt;
        &lt;list ordered="0" role="#KNIT" type="w.type"&gt;
          &lt;cdata format="PMLREF"/&gt;
        &lt;/list&gt;
      &lt;/member&gt;
      &lt;member name="constituents" role="#CHILDNODES"&gt;
        &lt;list ordered="1" type="node.type"/&gt;
      &lt;/member&gt;
    &lt;/structure&gt;
  &lt;/type&gt;
  &lt;!--  ============ derived from label.type ============  --&gt;
  &lt;type name="label.type"&gt;
    &lt;choice&gt;
      &lt;value&gt;VP&lt;/value&gt;
      &lt;value&gt;NP&lt;/value&gt;
      &lt;value&gt;PP&lt;/value&gt;
      &lt;value&gt;ADVP&lt;/value&gt;
      &lt;!-- etc. --&gt;
      &lt;value&gt;SDECL&lt;/value&gt;
      &lt;value&gt;SIMP&lt;/value&gt;
      &lt;value&gt;SQUEST&lt;/value&gt;
    &lt;/choice&gt;
  &lt;/type&gt;
  &lt;!--  =============================================================  --&gt;
  &lt;!--  ============ import schema="example1_schema.xml"  type="meta.type"============  --&gt;
  &lt;type name="meta.type"&gt;
    &lt;structure&gt;
      &lt;member name="annotator"&gt;
        &lt;cdata format="any"/&gt;
      &lt;/member&gt;
      &lt;member name="datetime"&gt;
        &lt;cdata format="any"/&gt;
      &lt;/member&gt;
    &lt;/structure&gt;
  &lt;/type&gt;
  &lt;!--  ==============================================================================  --&gt;
  &lt;type name="newmeta.type"&gt;
    &lt;structure&gt;
      &lt;member name="lang"&gt;
        &lt;cdata format="any"/&gt;
      &lt;/member&gt;
      &lt;member name="changes"&gt;
        &lt;list type="changes.type" ordered="1"/&gt;
      &lt;/member&gt;
    &lt;/structure&gt;
  &lt;/type&gt;
  &lt;!--  ============ derived from meta.type ============  --&gt;
  &lt;type name="changes.type"&gt;
    &lt;structure&gt;
      &lt;member name="annotator"&gt;
        &lt;cdata format="any"/&gt;
      &lt;/member&gt;
      &lt;member name="datetime"&gt;
        &lt;cdata format="any"/&gt;
      &lt;/member&gt;
      &lt;member name="id" role="#ID" as_attribute="1" required="1"&gt;
        &lt;cdata format="ID"/&gt;
      &lt;/member&gt;
      &lt;member name="desc"&gt;
        &lt;cdata format="any"/&gt;
      &lt;/member&gt;
    &lt;/structure&gt;
  &lt;/type&gt;
&lt;/pml_schema&gt;
</pre></div></div></div></div></div></body></html>
