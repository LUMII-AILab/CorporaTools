#!/bin/bash
# pml_validate     pajas@ufal.mff.cuni.cz     2010/03/16 10:26:37

readlink_nf () {
    perl -MCwd -e 'print Cwd::abs_path(shift)' "$1"
}

basedir=$(readlink_nf $(readlink_nf $(dirname $0))/..)
paths=.
keep=0
validate_schema=0
check_tools=0

VERSION=1.0
PRINT_USAGE=0
PRINT_HELP=0
PRINT_VERSION=0
DEBUG=0
QUIET=0

args=()
while [ $# -gt 0 ]; do
    case "$1" in
        -k|--keep)    keep=1 ; shift ;;
        -s|--schema)  validate_schema=1 ; shift ;;
        -p|--path)   paths=$2 ; shift 2 ;;
        -d|--pml-dir)   basedir=$2 ; shift 2 ;;
        -r|--rng-tool)   validator=$2 ; shift 2 ;;
        -c|--check-tools)   check_tools=1 ; shift ;;
        -D|--debug) DEBUG=1 ; shift ;;
	-q|--quiet) QUIET=1; shift ;;
	-u|--usage) PRINT_USAGE=1; shift ;;
	-h|--help) PRINT_HELP=1; shift ;;
	-v|--version) PRINT_VERSION=1; shift ;;
	--) shift ; break ;;
        -[^-]) echo "Invalid command-line option: $1!" >&2 ; exit 1 ;;
	-|*) args+=("$1"); shift ;;
    esac
done

eval set -- "$@" "${args[@]}"

function usage () {
    echo "$(basename $0) version $VERSION" 
    cat <<USAGE
$(basename $0) [-h|--help]|[-u|--usage]|[-v|--version]
or
$(basename $0) [-D|--debug] [-q|--quiet] ...
USAGE
}

function help () {
    usage
    cat <<HELP

  DESCRIPTION:

    For each PML instance on the command line, this script determines
    its PML schema, converts it to RelaxNG and validates the instance
    against the resulting RelaxNG schema via Sun's Multi-Schema
    Validator (msv), Sun's Relames, or J.Clark's Jing (jing).

    If the flag -s is used, the script takes PML schemas rather than
    instances and validates them against pml_schema.rng.

  OPTIONS:

      -p|--path        - directories with PML schemas
      -s|--schema      - validate a PML schema (rather than an instance)
      -k|--keep        - keep a temporary directory with partial results
      -r|--rng-tool    - path to RNG validator (jing, relames, ...)
      -c|--check-tools - test if RNG validator and pml_simplify are present and exit

      -d|--pml-dir     - the directory where PML Toolkit is installed (usualy
                         determined automatically from the location of this script)

      -h|--help    - print this help and exit
      -u|--usage   - print a short usage and exit
      -v|--version - print version and exit

      -D|--debug - turn on verbose output
      -q|--quiet - turn off informative messages

  AUTHOR:
      Copyright 2007-2010 by pajas@ufal.mff.cuni.cz
HELP
}

if [ $PRINT_VERSION = 1 ]; then echo Version: $VERSION; exit; fi
if [ $PRINT_HELP = 1 ]; then help; exit; fi
if [ $PRINT_USAGE = 1 ]; then usage; exit; fi

get_schema () {
  file="$1"
  schema=`perl -MXML::LibXML::Reader -e '
  my $r=XML::LibXML::Reader->new(location=>shift) || die "$!";
  $r->nextElement("schema"); 
  print $r->getAttribute("href"),"\n"' "$file"`
  if [ -z "$schema" ]; then
      schema="$file"
  elif [ "$(basename $schema)" = "$schema" ]; then
      for p in $(dirname "$file") ${paths//:/ }; do
	  if [ -f "$p/$schema" ]; then
	      schema="$p/$schema";
	      break;
	  fi
      done
  fi
  echo "$schema" 2>&1
}

msg () {
    if [ "$DEBUG" = 1 ]; then
	echo "$@"
    fi
}

cleanup () {
    if [ $keep =  1 ]; then
	echo "Temporary files kept in: $temp"
    elif [ -n "$temp" ] && [ -d "$temp" ]; then
	msg "Removing temporary files"
	rm -rf "$temp"
    fi
}
fail () {
    echo "ERROR $2";
    cleanup
    exit $1;
}

if [ $check_tools = 0 ] && [ $# = 0 ]; then
  usage;
fi

msg -n "Looking up pml_simplify: "
pml_simplify="$basedir/bin/pml_simplify"
if [ ! -x  $pml_simplify ]; then 
    pml_simplify=`which $basedir/tools/pml_simplify 2>/dev/null`
    if [ -x "$pml_simplify" ]; then
	fail 120 "Utility pml_simplify not found!"
    fi 
fi
msg $pml_simplify

msg -n "Looking up a RNG validator: "
if [ -z "$validator" ]; then
    if [ -n "$MSV" ] && [ -f "$MSV" ] && [ -x "$basedir/tools/msv" ]; then
	validator="$basedir/tools/msv"
    elif [ -n "$RELAMES" ] && [ -f "$RELAMES" ] && [ -x "$basedir/tools/relames" ]; then
	validator="$basedir/tools/relames"
    else
	validator=`which jing 2>/dev/null`
    fi
elif [ ! -x "$validator" ]; then
    fail 120 "Validator command '$validator' not found!"
fi
msg "$validator"

if [ -z "$validator" ] || [ ! -x "$validator" ]; then
    fail 120 "No validator found!
Use the --validator option or fix one of these:
  msv     - variable \$MSV must point to msv.jar
  relames - variable \$RELAMES must point to relames.jar
  jing    - 'jing' command must be in PATH
"
fi

if [ $check_tools = 1 ]; then
    [ $# = 0 ] || usage;
    echo "Tools OK"
    exit 0
fi

i=0;total=$#;
while [ $# -gt 0 ]; do
    file="$1"; shift
    msg "Instance: $file ($((++i))/$total)"

    temp=`mktemp -d` || fail 126 "Cannot create a temporary directory!"

    if [ "${file}" = "-" ]; then
	msg "Creating temporary copy of STDIN"
	cat "$file" > "$temp/data.pml" || fail 123 "Copying failed" 
	file="$temp/data.pml";
    fi

    if [ $validate_schema = 1 ]; then
	schema="$file"
    else
	schema=`get_schema "$file"`
    fi
    msg "Schema: $schema"

    msg "Simplifying schema"
    "$pml_simplify" --path "$paths" "$schema" > "$temp/simple_schema.xml" || fail 125 "Schema simplification failed"
    if [ $validate_schema = 1 ]; then
	msg "Validating schema using $validator and RNG '$basedir/rng/pml_schema.rng'" 2>&1 
	"$validator" "$basedir/rng/pml_schema.rng" "$temp/simple_schema.xml"    
    else
	msg "Transforming to Relax NG"
	xsltproc --param standalone 1 "$basedir/tools/pml2rng.xsl" "$temp/simple_schema.xml" > "$temp/schema.rng" \
	    || fail 124 "XSLT transformation failed"
	if [ "${file%.gz}" != "${file}" ]; then
	    msg "Ungzipping the instance to a temporary directory"
	    zcat < "$file" > "$temp/data.pml" || fail 123 "Gunzip failed" 
	    file="$temp/data.pml";
	fi 
	msg "Validating instance using $validator" 2>&1 
	cp "$basedir/rng/pml_schema.rng" "$basedir/rng/pml_schema_1_1.rng" "$basedir/rng/pml_schema_1_2.rng" "$temp/"
	"$validator" "$temp/schema.rng" "$file"
    fi
    exit=$?
    if [ $exit = 0 ]; then
	msg "Result: valid"
    else
	msg "Result: not valid"
    fi
    cleanup
    if [ $exit != 0 ]; then
	exit $exit
    fi
done

exit 0

