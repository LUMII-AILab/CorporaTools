<?xml version="1.0" encoding="utf-8"?>
<!-- -*- mode: xsl; coding: utf8; -*- -->
<!-- Author: pajas@ufal.ms.mff.cuni.cz -->

<xsl:stylesheet
  xmlns:xsl='http://www.w3.org/1999/XSL/Transform' 
  xmlns='http://ufal.mff.cuni.cz/pdt/pml/' 
  xmlns:s='http://ufal.mff.cuni.cz/pdt/pml/schema/' 
  version='1.0'>
<xsl:output method="xml" encoding="utf-8" indent="yes"/>
<xsl:strip-space elements="*"/>

<xsl:key name="id" match="nt|t" use="@id"/>

<xsl:template match="/">
  <xsl:apply-templates select="node()"/>
</xsl:template>

<xsl:template match="*">
  <xsl:element namespace="http://ufal.mff.cuni.cz/pdt/pml/" name="{local-name()}">
    <xsl:apply-templates select="@*"/>
    <xsl:apply-templates select="node()"/>
  </xsl:element>
</xsl:template>

<xsl:template match="head">
  <head>
    <schema>
      <xsl:apply-templates select="annotation"/>
    </schema>
  </head>
  <xsl:apply-templates select="meta"/>
</xsl:template>

<xsl:template match="annotation">
  <s:pml_schema version="1.1">
    <s:revision>0.1</s:revision>
    <s:description>Automatically generated by tiger2pml.xsl</s:description>
    <s:root name="corpus">
      <s:structure>
	<s:member name="id" role="#ID" as_attribute="1">
          <s:cdata format="ID"/>
        </s:member>
        <s:member name="meta" type="meta.type"/>
        <s:member name="body" type="body.type"/>
      </s:structure>
    </s:root>
    <s:type name="meta.type">
      <s:structure>
        <s:member name="name"><s:cdata format="any"/></s:member>
        <s:member name="author"><s:cdata format="any"/></s:member>
        <s:member name="date"><s:cdata format="any"/></s:member>
        <s:member name="description"><s:cdata format="any"/></s:member>
        <s:member name="format"><s:cdata format="any"/></s:member>
        <s:member name="history"><s:cdata format="any"/></s:member>
      </s:structure>
    </s:type>
    <s:type name="body.type">
      <!-- subcorpus not implemented -->
      <s:sequence role="#TREES">
        <s:element name="s" type="sentence.type"/>
      </s:sequence>
    </s:type>
    <s:type name="sentence.type">
      <s:structure role="#NODE">
        <s:member name="id" role="#ID" as_attribute="1">
          <s:cdata format="ID"/>
        </s:member>
        <s:member name="root" role="#CHILDNODES">
          <s:sequence content_pattern="(nonterminal|terminal)">
            <s:element name="nonterminal" type="nonterminal.type"/>
            <s:element name="terminal" type="terminal.type"/>
          </s:sequence>
        </s:member>
      </s:structure>
    </s:type>
    <s:type name="nonterminal.type">
      <s:structure role="#NODE">
        <s:member name="id" role="#ID" as_attribute="1">
          <s:cdata format="ID"/>
        </s:member>
        <s:member name="label" type="edgelabel.type"/>
        <xsl:apply-templates select="feature[@domain='NT' or @domain='FREC']"/>
        <s:member name="secedges">
          <s:sequence>
            <s:element name="secedge" type="secedge.type"/>
          </s:sequence>
        </s:member>
        <s:member name="children" role="#CHILDNODES">
          <s:sequence content_pattern="(nonterminal|terminal)*">
            <s:element name="nonterminal" type="nonterminal.type"/>
            <s:element name="terminal" type="terminal.type"/>
          </s:sequence>
        </s:member>
      </s:structure>
    </s:type>
    <s:type name="terminal.type">
      <s:structure role="#NODE">
        <s:member name="id" role="#ID" as_attribute="1">
          <s:cdata format="ID"/>
        </s:member>
        <s:member name="order" role="#ORDER"><s:cdata format="nonNegativeInteger"/></s:member>
        <s:member name="label" type="edgelabel.type"/>
        <xsl:apply-templates select="feature[@domain='T' or @domain='FREC']"/>
        <s:member name="secedges">
          <s:sequence>
            <s:element name="secedge" type="secedge.type"/>
          </s:sequence>
        </s:member>
      </s:structure>
    </s:type>
    <s:type name="secedge.type">
      <s:structure>
        <s:member name="idref" required="1">
          <s:cdata format="PMLREF"/>
        </s:member>
        <s:member name="label" required="0">
          <xsl:apply-templates select="secedgelabel"/>
        </s:member>
      </s:structure>
    </s:type>
    <s:type name="edgelabel.type">
      <xsl:apply-templates select="edgelabel"/>
    </s:type>
    <xsl:apply-templates select="annotation"/>
  </s:pml_schema>
</xsl:template>

<xsl:template match="feature">
  <s:member name="{@name}">
    <xsl:call-template name="feature.value"/>
  </s:member>
</xsl:template>

<xsl:template match="edgelabel|secedgelabel" name="feature.value">
  <xsl:choose>
    <xsl:when test="value">
      <s:choice>
        <xsl:apply-templates select="value"/>
      </s:choice>
    </xsl:when>
    <xsl:otherwise>
      <s:cdata format="any"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="value">
  <s:value><xsl:value-of select="@name"/></s:value>
</xsl:template>

<xsl:template match="graph">
  <root>
    <xsl:apply-templates select="key('id',@root)">
    </xsl:apply-templates>
  </root>
</xsl:template>

<xsl:template match="t">
  <xsl:param name="label"/>
  <terminal>
    <xsl:apply-templates select="@*"/>
    <order><xsl:value-of select="count(preceding-sibling::t)"/></order>
    <xsl:if test="$label!=''">
      <label><xsl:value-of select="$label"/></label>
    </xsl:if>
    <xsl:if test="secedge">
      <secedges>
	<xsl:apply-templates select="secedge"/>
      </secedges>
    </xsl:if>
  </terminal>
</xsl:template>

<xsl:template match="nt">
  <xsl:param name="label"/>
  <nonterminal>
    <xsl:apply-templates select="@*"/>
    <xsl:if test="$label!=''">
      <label><xsl:value-of select="$label"/></label>
    </xsl:if>
    <xsl:if test="secedge">
      <secedges>
	<xsl:apply-templates select="secedge"/>
      </secedges>
    </xsl:if>
    <xsl:if test="edge">
      <children>
	<xsl:apply-templates select="edge">
	  <!-- we order terminals by their document order
               and nonterminals by the order of 
               the first terminal found on 1st, 2nd, or 3rd level below them
            -->
	  <xsl:sort select="count(
                         key('id',@idref)/self::t/preceding-sibling::t
                         |
                         (key('id',key('id',@idref)/self::nt/edge/@idref
			          |
                                  key('id',key('id',@idref)/self::nt/edge/@idref)/self::nt/edge/@idref
                                  |
                                  key('id',key('id',key('id',@idref)/self::nt/edge/@idref)/self::nt/edge/@idref)/self::nt/edge/@idref
			     )/self::t
			 )[1]/preceding-sibling::t
			 )" data-type="number" order="ascending"/>
	</xsl:apply-templates>
      </children>
    </xsl:if>
  </nonterminal>
</xsl:template>

<xsl:template match="edge">
  <xsl:apply-templates select="key('id',@idref)">
    <xsl:with-param name="label" select="@label"/>
  </xsl:apply-templates>
</xsl:template>

<xsl:template match="@*">
  <xsl:choose>
    <xsl:when test="name()='id'">
      <xsl:copy/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:element name="{name()}">
	<xsl:value-of select="string(.)"/>
      </xsl:element>
    </xsl:otherwise>
  </xsl:choose>
</xsl:template>

<xsl:template match="subcorpus">
  <xsl:message terminate="yes">Tag 'subcorpus' not supported!</xsl:message>
</xsl:template>
<xsl:template match="matches">
  <xsl:message terminate="yes">Tag 'matches' not supported!</xsl:message>
</xsl:template>

</xsl:stylesheet>
