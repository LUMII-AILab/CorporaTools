#!btred -t PML -e pml2netgraph()
# -*- cperl -*-

=head1 pml2netgraph.btred

Converts tdata or adata to FS format for NetGraph.

=head1 SYNOPSIS

  btred -I pml2netgraph.btred [ -o <options> -- ] files ...
or
  ntred -i files ... 
  ntred -I pml2netgraph.btred [ -- <options>]

=head1 OUTPUT

The output files are named as the originals with possible C<.pls> or
C<.pls.gz> extensions stripped and C<.fs> appended. The original
filenames may be adjusted using C<btred>'s renaming options.

=head1 DESCRIPTION

This script transforms an adata or a tdata PML instance to
a corresponding FS file suitable for use with the NetGraph Server. In
case of adata, only minor changes to the naming of attributes are done
(mdata and wdata are naturally embedded).

In case of tdata the conversion is more complex: for every a-node
referred in the element C<a> of a t-node a phantom copy is created and
planted as a hidden child-node of the referring t-node. This copy also
embeds complete m-layer and w-layer information of the original
a-node. Node attributes of the a-layer start with the prefix C<a/>.

The following btred/ntred flags can be useful:

C<-a|-r|-s|-p> - affect filenames of the output files

=head1 SCRIPT OPTIONS

=over 5

=item --value-attribute|-V <attribute_name>

Specify the name of an attribute to declare as @V in the FS file header (only for non-PDT formats)

=item --balance|-b

Indicate that if the data format does not define an ordering
attribute, the ordering attribute '#order' should be defined and
initialized in the following way: index leaf nodes starting from 1 and
set the index of a non-leaf node to be the average of indexes of its
child nodes.

=back

=head1 AUTHOR

Petr Pajas <pajas@matfyz.cz>

Copyright 2005 Petr Pajas, All rights reserved.

=cut

#ifndef NTRED
#include <tred.mac>
#endif

package TredMacro;
our %opts;
use Getopt::Long ();
sub start_hook {
  Getopt::Long::GetOptions(
    \%opts,
    'value-attribute|V=s',
    'balance|b',
   ) or die "Wrong options\n";
}

sub start_hook {
  warn("The conversion is one way only, some information may be lost!\n");
}

package PML;
use strict;

sub pml2netgraph {
  my $name = SchemaName();
  if ($name eq 'adata') {
    PML_A::adata2netgraph();
  } elsif ($name eq 'tdata') {
    PML_T::tdata2netgraph();
  } elsif ($name eq 'valency_lexicon') {
    PML::vallex2netgraph();
  } else {
    PML::other2netgraph();
  }
}

package PML_T;
use PMLSchema;

#binding-context PML_T
#bind tdata2netgraph to G

sub tdata2netgraph {
  die "Can't operate on non tdata file\n" unless SchemaName() eq 'tdata';
  my $filename = FileName();
  $filename=~/\.pls(\.gz)?$/;
  $filename.='.fs';
  my $defs = FS()->defs;
  my $new_defs = {};
  my $type_defs = {};
  my %attrs_cache; # paths to all atomic subtypes of a given type (i.e. /-delimited attributes)
  my %members_cache; # names of struct members
  my $schema = Schema();
  foreach my $tree (GetTrees()) {
    my ($a_tree) = GetANodes($tree);
    $tree->{sentence} = PML_A::GetSentenceString($a_tree);
    foreach my $node ($tree,$tree->descendants) {

      # hang AID nodes to this one:
      my $i=1;
#      unless ($node == $tree) {
	my @a_same_tree = sort { $a->{ord} <=> $b->{ord} } grep { $_->root == $a_tree } GetANodes($node);
	my @a_other_trees = sort { $a->{ord} <=> $b->{ord} } grep { $_->root != $a_tree } GetANodes($node);
	my $lex_rf = $node->attr('a/lex.rf'); $lex_rf=~s/.*#//;
	for my $anode (@a_other_trees,@a_same_tree) {
	  my $new = FSNode->new();
	  $new->{'a/ref_type'} = (!$anode->parent ? 'tree' :
				    ($lex_rf eq $anode->{id} ? 'lex' : 'aux'));
	  $new->{'a/id'} = $anode->{id};
	  $new->{'a/ord'} = ($anode->root == $a_tree ? $anode->{ord} : '');
	  $new->{'a/afun'} = $anode->{afun};
	  $new->{'a/is_member'} = $anode->{is_member};
	  $new->{'hide'} = 'true';
	  $new->{'m/tag'} = $anode->{'m'}{tag};
	  $new->{'m/lemma'} = $anode->{'m'}{lemma};
	  $new->{'m/form'} = $anode->{'m'}{form};
	  $new->{'w/token'} = join '|',map { $_->{token} } ListV($anode->{'m'}{'w'});
	  $new->{'w/no_space_after'} = join '|',map { $_->{no_space_after} } ListV($anode->{'m'}{'w'});
	  $new->{'deepord'} = $node->{deepord}.".".$i;
	  $new->{'a/parent'} = $anode->parent->{id} if $anode->parent;
	  { 
	    my @ep = PML_A::GetEParents($anode,\&PML_A::DiveAuxCP);
	    $new->{'a/eparents'} = join "|", map { $_->{id} } @ep;
	    $new->{'a/eparents_diff'} = join "|", map { $_->{id} } grep{ $_ != $anode->parent } @ep;
	  }
	  $i++;
	  PasteNode($new,$node);
	}
#      }

      my $new_node = {};
      my $type = $node->type;
      $attrs_cache{$type} = [grep {$_ !~ m{^a\/} }  $schema->attributes($node->type)] 
	unless exists $attrs_cache{$type};
      $members_cache{$type} = [grep {$_ ne 'a'} $node->type->get_members()] unless exists $members_cache{$type};
      foreach my $attr (@{ $attrs_cache{$type} }) {
	my $fs_attr = $attr;
	#$fs_attr=~s{/}{_}g;

	# declare if not yet declared
	if (!exists $new_defs->{$fs_attr} or !exists($type_defs->{ $node->type->type_decl->{name}.">".$fs_attr })) {
	  my $attr_type = $node->type->find($attr);
	  my $attr_decl_type = $attr_type->get_decl_type;
	  if ($attr_decl_type == PML_LIST_DECL() or $attr_decl_type == PML_ALT_DECL()) {
	    $attr_type = $attr_type->get_content_decl;
	    $attr_decl_type = $attr_type->get_decl_type;
	  }
	  if (($attr_decl_type == PML_CHOICE_DECL()) or ($attr_decl_type == PML_CONSTANT_DECL())) {
	    if (defined $new_defs->{$fs_attr}) {
	      foreach (sort $attr_type->get_values) {
		$new_defs->{$fs_attr} .= "|".$_ unless $new_defs->{$fs_attr}=~/\|\Q$_\E($|\|)/;
	      }
	    } else {
	      $new_defs->{$fs_attr} = ' P L='.join '|',map { /[,=\|\[\]]/ ? '\\'.$_ : $_} sort $attr_type->get_values;
	    }
	  } else {
	    $new_defs->{$fs_attr} = ' P';
	  }
	  $type_defs->{ $node->type->type_decl->{name}.">".$fs_attr } = 1;
	}
	my $value = $node->attr($attr);
	if (IsList($value) or IsAlt($value)) {
	  $new_node->{$attr} = join "|",ListV($value);
	} else {
	  $new_node->{$attr} = $value;
	}
      }
      {
	my @ep = PML_T::GetEParents($node);
	$new_node->{'eparents'} = join "|",map { $_->{id} } @ep;
	$new_node->{'eparents_diff'} = join "|",map { $_->{id} } grep{ $_ != $node->parent } @ep;
      }
      delete $node->{$_} for @{$members_cache{$type}};
      $node->set_type(undef);
      $node->{$_}=$new_node->{$_} for keys %$new_node;
    }
  }
  my $fsfile = CurrentFile();
  my $afile = AFile();
  if ($afile) {
    # writeln("deleting fs-part-of from a-file\n");
#    my $part_of = $afile->appData('fs-part-of');
#    @$part_of = grep { $_ != $fsfile } @{$part_of} if ref($part_of);
    #  } else {
    #    writeln("no a-file\n");
  }

  for (keys %$new_defs) {
    $defs->{$_} = $new_defs->{$_} unless exists $defs->{$_};
  }
  @{FS()->list} = (sort(keys(%$new_defs),qw(sentence eparents eparents_diff)),
		   sort(qw(a/id a/ref_type a/afun a/is_member a/ord a/parent a/eparents a/eparents_diff)),
		   sort(qw(m/form m/lemma m/tag)),
		   sort(qw(w/token w/no_space_after)),
		   qw(hide));
  $defs->{$_} = ' P' for qw(m/form m/lemma m/tag w/token a/id a/parent a/eparents a/eparents_diff eparents eparents_diff);
  $defs->{'a/ref_type'} = ' P L=aux|lex|tree';
  $defs->{$_} = ' P L=0|1' for qw(a/is_member w/no_space_after);
  my @afuns = uniq('---',sort(map {
    $_->get_member_by_name('afun')->get_content_decl->get_values
  } $afile->metaData('schema')->node_types()));

  $defs->{'a/afun'} = ' P L='.join ('|',@afuns);

  $defs->{hide} = ' H L=true|false';
  $defs->{sentence} = ' V';
  $defs->{'a/ord'} = ' W';

  FileMetaData("schema",undef);
#  FileMetaData("fs-require",undef);
  FileMetaData("ref",{});
  FileMetaData("ref-index",{});
  $fsfile->changeFilename($filename);
  $fsfile->changeBackend('FSBackend');
  $fsfile->changeEncoding('utf-8');

  ChangingFile(1);
}

package PML_A;
use PMLSchema;
#binding-context PML_A
#bind adata2netgraph to G

sub adata2netgraph {
  die "Can't operate on non adata file\n" unless SchemaName() eq 'adata';
  my $filename = FileName();
  $filename =~ s/\.pls(\.gz)?//;
  $filename .= ".fs";

  my $defs = FS()->defs;
  my $new_defs = {};
  my $type_defs = {};
  my %attrs_cache; # paths to all atomic subtypes of a given type (i.e. /-delimited attributes)
  my %members_cache; # names of struct members
  my $schema = Schema();
  foreach my $tree (GetTrees()) {
    foreach my $node ($tree,$tree->descendants) {
      my $new_node = {};
      my $type = $node->type;
      $attrs_cache{$type} = [$schema->attributes($node->type)] unless exists $attrs_cache{$type};
      $members_cache{$type} = [$node->type->get_members()] unless exists $members_cache{$type};
      foreach my $attr (@{ $attrs_cache{$type} }) {
	my $fs_attr = $attr;
	#$fs_attr=~s{/}{_}g;

	# declare if not yet declared
	if (!exists $new_defs->{$fs_attr} or
	    !exists($type_defs->{ $node->type->type_decl->{name}.">".$fs_attr })) {
	  $type_defs->{ $node->type->type_decl->{name}.">".$fs_attr } = 1;
	  my $attr_type = $node->type->find($attr);
	  my $attr_decl_type = $attr_type->get_decl_type;
	  if ($attr_decl_type == PML_LIST_DECL() or $attr_decl_type == PML_ALT_DECL()) {
	    $attr_type = $attr_type->get_content_decl;
	    $attr_decl_type = $attr_type->get_decl_type;
	  }
	  if (($attr_decl_type == PML_CHOICE_DECL()) or ($attr_decl_type == PML_CONSTANT_DECL())) {
	    if (defined $new_defs->{$fs_attr}) {
	      foreach (sort $attr_type->get_values) {
		$new_defs->{$fs_attr} .= "|".$_ unless $new_defs->{$fs_attr}=~/\|\Q$_\E($|\|)/;
	      }
	    } else {
	      $new_defs->{$fs_attr} = ' P L='.join '|',sort $attr_type->get_values;
	    }
	  } else {
	    $new_defs->{$fs_attr} = ' P';
	  }
	}
	my $value = $node->attr($attr);
	if (IsList($value) or IsAlt($value)) {
	  $new_node->{$attr} = join "|",ListV($value);
	} else {
	  $new_node->{$attr} = $value;
	}
      }
      {
	my @ep = PML_A::GetEParents($node,\&PML_A::DiveAuxCP);
	$new_node->{'eparents'} = join "|",map { $_->{id} } @ep;
	$new_node->{'eparents_diff'} = join "|",map { $_->{id} } grep { $_!=$node->parent } @ep;
      }
      delete $node->{$_} for @{$members_cache{$type}};
      $node->set_type(undef);
      for (keys %{$new_node},'eparents','eparents_diff') {
	if (m{^m/(w/.*)$}) {
	  $node->{$1}=$new_node->{$_};
	} else {
	  $node->{$_}=$new_node->{$_};
	}
      }
    }
  }

  $defs->{eparents} = ' P';
  $defs->{eparents_diff} = ' P';
  $defs->{'m/w/token'} = ' V'.$defs->{'m/w/token'};
  for (keys %$defs) {
    $defs->{$1} = delete $defs->{$_} if m{^m/(w/.*)$};
  }
  for (keys %$new_defs) {
    $new_defs->{$1} = delete $new_defs->{$_} if m{^m/(w/.*)$};
  }
  for my $attr (keys %$new_defs) {
    $defs->{$attr} = $new_defs->{$attr} unless exists $defs->{$attr};
  }
  my @attrs = grep { !m/^ / } keys(%$defs); # filter out e.g. _SPEC
  @{FS()->list} = (sort(grep !m{^[mw]/}, @attrs),
		   sort(grep m{^[mw]/}, @attrs));

  my $fsfile = CurrentFile();
  FileMetaData("schema",undef);
  FileMetaData("fs-require",undef);
  FileMetaData("ref",{});
  FileMetaData("ref-index",{});
  $fsfile->changeFilename($filename);
  $fsfile->changeBackend('FSBackend');
  $fsfile->changeEncoding('utf-8');

  ChangingFile(1);
}

package PML;
use PMLSchema;

sub _balance_subtree {
  my ($node,$last)=@_;
  if ($node->firstson) {
    my $sum=0;
    my $count=0;
    for ($node->children) {
      $last=_balance_subtree($_,$last);
      $sum+=$_->{'#order'};
      $count++;
    }
    $node->{'#order'}=int($sum/$count);
    return $last;
  } else {
    return $node->{'#order'}=$last+1;
  }
}

sub other2netgraph {
  die "Can't operate on a non-PML file\n" unless SchemaName();
  my $filename = FileName();
  $filename =~ s/\.pls(\.gz)?//;
  $filename .= ".fs";

  my $defs = FS()->defs;
  my $order = FS()->order;
  my $new_defs = {};
  my $type_defs = {};
  my %attrs_cache; # paths to all atomic subtypes of a given type (i.e. /-delimited attributes)
  my %members_cache; # names of struct members
  my $schema = Schema();
  my @names = map { $_->get_element_names } grep { $_->get_decl_type==PML_SEQUENCE_DECL }
    uniq map { $schema->find_type_by_path($_) } ($schema->find_role('#CHILDNODES'), $schema->find_role('#TREES'));
  my $no;
  foreach my $tree (GetTrees()) {
    foreach my $node ($tree,$tree->descendants) {
      my $new_node = {};
      my $type = $node->type;
      $attrs_cache{$type} = [$schema->attributes($node->type)] unless exists $attrs_cache{$type};
      $members_cache{$type} = [$node->type->get_members()] unless exists $members_cache{$type};
      foreach my $attr (@{ $attrs_cache{$type} }) {
	my $fs_attr = $attr;
	# declare if not yet declared
	if (!exists $new_defs->{$fs_attr} or
	    !exists($type_defs->{ $node->type->type_decl->{name}.">".$fs_attr })) {
	  $type_defs->{ $node->type->type_decl->{name}.">".$fs_attr } = 1;
	  my $attr_type = $node->type->find($attr);
	  my $attr_decl_type = $attr_type->get_decl_type;
	  if ($attr_decl_type == PML_LIST_DECL() or $attr_decl_type == PML_ALT_DECL()) {
	    $attr_type = $attr_type->get_content_decl;
	    $attr_decl_type = $attr_type->get_decl_type;
	  }
	  if (($attr_decl_type == PML_CHOICE_DECL()) or ($attr_decl_type == PML_CONSTANT_DECL())) {
	    if (defined $new_defs->{$fs_attr}) {
	      foreach (sort $attr_type->get_values) {
		$new_defs->{$fs_attr} .= "|".$_ unless $new_defs->{$fs_attr}=~/\|\Q$_\E($|\|)/;
	      }
	    } else {
	      $new_defs->{$fs_attr} = ' P L='.join '|',map { /[,=\|\[\]]/ ? '\\'.$_ : $_} sort $attr_type->get_values;
	    }
	  } else {
	    $new_defs->{$fs_attr} = ' P';
	  }
	}
	my $value = $node->attr($attr);
	if (IsList($value) or IsAlt($value)) {
	  $new_node->{$attr} = join "|",ListV($value);
	} else {
	  $new_node->{$attr} = $value;
	}
      }
      if (!defined($order) and !$opts{balance}) {
	$new_node->{'#order'}=$no++;
      }
      delete $node->{$_} for @{$members_cache{$type}};
      $node->set_type(undef);
      for (keys %{$new_node}) {
	$node->{$_}=$new_node->{$_};
      }
    }
    _balance_subtree($tree,0) if !defined $order and $opts{balance};
  }
  $new_defs->{'#name'} = ' P L='.join('|',map { /[,=\|\[\]]/ ? '\\'.$_ : $_} @names) if (@names);
  for my $attr (keys %$new_defs) {
    $defs->{$attr} = $new_defs->{$attr} unless exists $defs->{$attr};
  }
  my $value_attr=$opts{'value-attribute'};
  if (defined $value_attr) {
    if (exists $defs->{$value_attr}) {
      $defs->{$value_attr}=' V'.$defs->{$value_attr};
    } else {
      warn "WARNING: Attribute '$value_attr' selected to be declared as \@V does not exist!\n";
    }
  }
  if (!defined $order) {
    $defs->{'#order'}=' N';
  }
  FS()->renew_specials;
  my @attrs = grep { !m/^ / } keys(%$defs); # filter out e.g. _SPEC
  @{FS()->list} = sort @attrs;
  my $fsfile = CurrentFile();
  FileMetaData("schema",undef);
  FileMetaData("fs-require",undef);
  FileMetaData("ref",{});
  FileMetaData("ref-index",{});
  $fsfile->changeFilename($filename);
  $fsfile->changeBackend('FSBackend');
  $fsfile->changeEncoding('utf-8');
  ChangingFile(1);
}


package PML;
use PMLSchema;
sub vallex2netgraph {
  my $filename = FileName();
  $filename =~ s/\.pml(\.gz)?//;
  $filename .= ".fs";

  my $defs = FS()->defs;
  my $new_defs = {};
  my $type_defs = {};
  my %attrs_cache; # paths to all atomic subtypes of a given type (i.e. /-delimited attributes)
  my %members_cache; # names of struct members
  my $schema = Schema();
  my %seen_L;
  foreach my $tree (GetTrees()) {
    foreach my $node ($tree,$tree->descendants) {
      delete($node->{afun}) if $node->{afun} eq 'unspecified';
      delete($node->{neg}) if $node->{afun} eq 'unspecified';
      my $new_node = {};
      my $name = $node->{'#name'};
      my $label;
      if ($name eq 'word') {
	$label = $node->{lemma}.".".$node->{POS};
      } elsif ($name eq 'frame') {
	($label) = split(/;/,$node->{example},2);
	$label = substr($label,0,50).'...' if length($label)>50;
      } elsif ($name eq 'element') {
	$label = ($node->{type} eq 'non-oblig' ? '?' : '') .$node->{functor};
      } elsif ($name eq 'node') {
	$label = q();
	if ($node->{form}) {
	  $label.='"'.$node->{form}.'"';
	} elsif ($node->{lemma}) {
	  $label.=$node->{lemma};
	}
 	my $morph = join('',
 			 ($node->{neg} eq 'negative' ? "~" : q()),
 			 (map {$node->{$_}} qw(pos gen num case)),
 			 ($node->{deg} ? "@".$node->{deg} : q()),
 			 ($node->{agreement} ? "#" : q()),
			 ( map { length($node->{'tagpos'.$_}) ? '$'.$_.'<'.$node->{'tagpos'.$_}.'>' : q() } 1..15 ),
 			);
 	if (length $morph) {
 	  $label.= ($node->{inherits} ? '.' : ':').$morph;
	}
      } elsif ($name =~ /elided|typical|recip|state/) {
	$label = $name;
      }
      $node->{'#label'} = $label;

      my $type = $node->type;
      $attrs_cache{$type} ||= [$schema->attributes($node->type)];
      $members_cache{$type} ||= [$node->type->get_members()];
      foreach my $attr (@{ $attrs_cache{$type} }) {
	my $fs_attr = $attr;
	#$fs_attr=~s{/}{_}g;
	# declare if not yet declared
	my $value = $node->attr($attr);
	if (defined($value) and length($value) and
	    (!exists $new_defs->{$fs_attr} or
	     !exists($type_defs->{ $node->type->type_decl->{name}.">".$fs_attr }))) {
	  $type_defs->{ $node->type->type_decl->{name}.">".$fs_attr } = 1;
	  my $attr_type = $node->type->find($attr);
	  if (defined $attr_type) {
	    my $attr_decl_type = $attr_type->get_decl_type;
	    if ($attr_decl_type == PML_LIST_DECL() or $attr_decl_type == PML_ALT_DECL()) {
	      $attr_type = $attr_type->get_content_decl;
	      $attr_decl_type = $attr_type->get_decl_type;
	    }
	    if (($attr_decl_type == PML_CHOICE_DECL()) or ($attr_decl_type == PML_CONSTANT_DECL())) {
	      $new_defs->{$fs_attr} = ' P L=';#.join '|',sort $attr_type->get_values;
	    } else {
	      $new_defs->{$fs_attr} = ' P';
	    }
	  }
	  if (IsList($value) or IsAlt($value)) {
	    $new_node->{$attr} = join "|",ListV($value);
	  } else {
	    $new_node->{$attr} = $value;
	  }
	}
	if ($new_defs->{$fs_attr} =~ / L=/ and defined($value) and length($value))  {
	  $seen_L{$fs_attr}{$value}=1;
	}
      }
      delete $node->{$_} for @{$members_cache{$type}};
      $node->{$_}=$new_node->{$_} for keys %$new_node;
      $node->set_type(undef);
    }
  }
  for my $attr (keys %$new_defs) {
    $defs->{$attr} = $new_defs->{$attr} unless exists $defs->{$attr};
  }
  for my $attr (keys %$defs) {
    if (exists $new_defs->{$attr}) {
      if ($defs->{$attr}=~/ L=/) {
	$defs->{$attr}.=join '|',
	  map { /[,=\|\[\]]/ ? '\\'.$_ : $_}
	  sort keys %{$seen_L{$attr}};
      }
    } else {
      delete $defs->{$attr};
    }
  }
  $defs->{'#name'}=' P';
  $defs->{'#label'}=' P';
  delete $defs->{abbrev};
  @{FS()->list} = (sort keys %$defs);

  my $fsfile = CurrentFile();
  FileMetaData("schema",undef);
  FileMetaData("fs-require",undef);
  FileMetaData("ref",{});
  FileMetaData("ref-index",{});
  $fsfile->changeFilename($filename);
  $fsfile->changeBackend('FSBackend');
  $fsfile->changeEncoding('utf-8');
  SetStylesheetPatterns(<<'PATTERNS',STYLESHEET_FROM_FILE);
node: ${#label}
rootstyle:#{balance:1}#{skipHiddenParents:1}#{skipHiddenLevels:1}
                #{CurrentOval-outline:red}#{CurrentOval-width:4}
                #{Node-currentwidth:10}#{Node-currentheight:10}#{Node-textalign:center}#{NodeLabel-halign:center}
style:<?
   $${#name} eq 'node' ? '#{Node-shape:oval}#{Oval-fill:yellow}#{Node-addwidth:4}#{Node-addheight:4}' :
   $${#name} eq 'form' ? ((
      ($this->children<=1) ? '#{Node-hide:1}' : q()
   ).'#{Node-shape:rectangle}#{Oval-fill:lightblue}') :
   $${#name} eq 'element' ? '#{Node-shape:oval}#{Oval-fill:green}#{Node-addwidth:4}#{Node-addheight:4}' :
   $${#name} eq 'word' ? '#{NodeLabel-dodrawbox:yes}#{NodeLabel-valign:bottom}#{Node-shape:oval}#{Oval-fill:orange}#{Node-addwidth:4}#{Node-addheight:4}' :
   $${#name} eq 'frame' ? '#{Node-shape:rectangle}#{Oval-fill:gray}#{Line-coords:n,n,n,p,p,p}' :
  q()
 ?>
text:<?
  if ($${#name} eq 'word') {
    $${lemma}."\n";
  } elsif ($${#name} eq 'frame') {
      my $text='';
      for my $el ($this->children) { 
         $text.='?' if $el->{type} eq 'non-oblig';
         $text.=$el->{functor}.'(';
         $text.=join ';', map {
            join ',', map { $_->{'#label'} } $_->children;
         } $el->children;
         $text.=') ';
      }
      $text.="\n".$${example}." (".$${used}."x)\n";
      $text;
  }
?>
PATTERNS
  ChangingFile(1);
  
}

1;
