<?xml version="1.0"?>
<grammar xmlns="http://relaxng.org/ns/structure/1.0"
	xmlns:s="http://ufal.mff.cuni.cz/pdt/pml/schema/"
        xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0"
        xmlns:sch="http://www.ascc.net/xml/schematron"
	datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <sch:ns prefix="s" uri="http://ufal.mff.cuni.cz/pdt/pml/schema/"/>
  <a:documentation>PML schema syntax (revision 1.1.3)</a:documentation>
  <start combine="choice">
    <ref name="pml_schema.element"/>
  </start>

  <define name="version">
    <value>1.1</value>
  </define>
  <define name="pml_schema.element">
    <element name="s:pml_schema">
      <attribute name="version">
	<ref name="version"/>
      </attribute>
      <optional>
	<element name="s:revision">
	  <ref name="revisionno.type"/>
	</element>
      </optional>
      <optional>
	<element name="s:description">
	  <text/>
	</element>
      </optional>
      <zeroOrMore>
	<ref name="reference.element"/>
      </zeroOrMore>
      <ref name="pml_schema.body"/>
    </element>
  </define>
  <define name="pml_schema.body">
    <zeroOrMore>
      <ref name="import.element"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="derive.element"/>
    </zeroOrMore>
    <optional>
      <ref name="root.element"/>
    </optional>
    <zeroOrMore>
      <ref name="type.element"/>
    </zeroOrMore>
  </define>
  <define name="import.element.attributes">
    <optional>
      <attribute name="type">
	<ref name="type_name.type"/>
      </attribute>
    </optional>
  </define>
  <define name="import.element">
    <element name="s:import">
      <a:documentation>
	instruction to import type(s) and root element from another
        PML schema
      </a:documentation>
      <attribute name="schema">
	<data type="anyURI"/>
      </attribute>
      <optional>
        <choice>
          <attribute name="revision"/>
          <group>
            <optional>
              <attribute name="minimal_revision">
		<ref name="revisionno.type"/>
	      </attribute>
	    </optional>
	    <optional>
	      <attribute name="maximal_revision">
		<ref name="revisionno.type"/>
	      </attribute>
	    </optional>
          </group>
        </choice>
      </optional>
      <ref name="import.element.attributes"/>
    </element>
  </define>

  <define name="derive.element">
    <element name="s:derive">
      <a:documentation>
	instruction to derive new type from an existing one (including
        one that is imported)
      </a:documentation>
      <attribute name="type">
	<data type="NCName"/>
      </attribute>
      <optional>
        <attribute name="name">
	  <ref name="type_name.type"/>
        </attribute>
      </optional>
      <choice>
        <element name="s:structure">
          <optional>
            <attribute name="name">
	      <data type="NCName"/>
	    </attribute>
          </optional>
          <optional>
            <ref name="role.attribute"/>
          </optional>
          <zeroOrMore>
            <ref name="member.element"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="delete.element"/>
          </zeroOrMore>
        </element>
       <element name="s:sequence">
          <optional><attribute name="content_pattern"/></optional>
          <optional><ref name="role.attribute"/></optional>
          <zeroOrMore>
            <ref name="element.element"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="delete.element"/>
          </zeroOrMore>
        </element>
       <element name="s:container">
          <optional><ref name="role.attribute"/></optional>
	  <optional><ref name="type.attribute"/></optional>
          <zeroOrMore>
            <ref name="attribute.element"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="delete.element"/>
          </zeroOrMore>
        </element>
        <element name="s:choice">
          <zeroOrMore>
            <element name="s:value">
              <text/>
            </element>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="delete.element"/>
          </zeroOrMore>
        </element>
      </choice>
    </element>
  </define>

 <define name="delete.element">
    <element name="s:delete">
      <a:documentation>delete instruction in derive element (depending
        on the context, contains name of a structure member, sequence
        element, or choice value)</a:documentation>
      <text/>
    </element>
  </define>

  <define name="type.decl">
    <choice>
      <ref name="type.attribute"/>
      <ref name="any.type"/>
    </choice>
  </define>

  <define name="any.type">
    <choice>
      <ref name="alt.element"/>
      <ref name="list.element"/>
      <ref name="data.type"/>
    </choice>
  </define>

  <define name="data.type">
    <choice>
      <ref name="choice.element"/>
      <ref name="constant.element"/>
      <ref name="structure.element"/>
      <ref name="sequence.element"/>
      <ref name="container.element"/>
      <ref name="cdata.element"/>
    </choice>
  </define>
  <define name="non-structure.type">
    <choice>
      <ref name="alt.element"/>
      <ref name="list.element"/>
      <ref name="choice.element"/>
      <ref name="constant.element"/>
      <ref name="sequence.element"/>
      <ref name="cdata.element"/>
    </choice>
  </define>

  <define name="role.attribute">
    <attribute name="role">
      <a:documentation>PML role of the value</a:documentation>
      <ref name="role.type"/>
    </attribute>
  </define>

  <define name="role.type">
    <choice datatypeLibrary="">
      <value type="string">#TREES</value>
      <value type="string">#NODE</value>
      <value type="string">#ORDER</value>
      <value type="string">#CHILDNODES</value>
      <value type="string">#ID</value>
      <value type="string">#HIDE</value>
    </choice>
  </define>

  <define name="root.element">
    <a:documentation>declaration of the root-element of a PML instance
    (except for the implicit obligatory &lt;head&gt;)</a:documentation>
    <element name="s:root">
      <attribute name="name">
	<ref name="name.type"/>
      </attribute>
      <choice>
	<ref name="type.attribute"/>
	<ref name="sequence.element"/>
	<ref name="structure.element"/>
	<ref name="container.element"/>
      </choice>
    </element>	
  </define>

  <define name="reference.element">
    <element name="s:reference">
      <a:documentation>declare a bound instance and optinally provide
        a hint for applications on how to parse it</a:documentation>
      <attribute name="name">
	<data type="NCName"/>
      </attribute>
      <optional>
	<attribute name="readas">
	  <choice datatypeLibrary="">
	    <value type="string">pml</value>
	    <value type="string">trees</value>
	    <value type="string">dom</value>
	  </choice>      
	</attribute>
      </optional>
    </element>
  </define>

  <define name="type.element">
    <element name="s:type">
      <a:documentation>a named complex type</a:documentation>
      <attribute name="name">
	<ref name="type_name.type"/>
      </attribute>
      <ref name="any.type"/>
    </element>
  </define>

  <define name="type.attribute">
    <attribute name="type">
      <a:documentation>a reference to a named complex type</a:documentation>
      <ref name="type_ref.type"/>
    </attribute>
  </define>

  <define name="structure.element">
    <element name="s:structure">
      <a:documentation>a structure (AVS)</a:documentation>
      <optional>
	<attribute name="name">
	  <data type="NCName"/>
	</attribute>
      </optional>
      <optional>	
 	<ref name="role.attribute"/>
      </optional>
      <oneOrMore>
	<ref name="member.element"/>
      </oneOrMore>
      <sch:pattern name="duplicite members">
        <sch:rule context="s:member">
          <sch:report test="count(../s:member[@name = current()/@name])>1">Structure definition contains two or more member declarations with the same name.</sch:report>
        </sch:rule>
      </sch:pattern>
    </element>
  </define>

  <define name="member.element">
    <element name="s:member">
      <a:documentation>a member of a structure</a:documentation>
      <optional><ref name="required.attribute"/></optional>
      <choice>
	<group>
	  <attribute name="as_attribute">
	    <value>1</value>
	  </attribute>
	  <attribute name="name">
	    <choice>
	      <data type="NCName"/>
	      <value type="Name">xml:id</value>
	    </choice>
	  </attribute>
	</group>
	<group>
	  <optional>
	    <attribute name="as_attribute">
	      <value>0</value>
	    </attribute>
	  </optional>
	  <attribute name="name">
	    <ref name="name.type"/>
	  </attribute>
	</group>
      </choice>	
      <choice>
	<group>
	  <attribute name="role">
	    <value datatypeLibrary="" type="string">#KNIT</value>
	  </attribute>
	  <attribute name="type">
	    <a:documentation>a reference to a named complex type
	    for knitting</a:documentation>
	    <ref name="type_ref.type"/>
	  </attribute>
	  <ref name="cdata.element"/>
	</group>
	<group>
	  <optional>
	    <ref name="role.attribute"/>
	  </optional>
	  <ref name="type.decl"/>
	</group>
      </choice>
    </element>
  </define>

  <define name="alt.element">
    <element name="s:alt">
      <a:documentation>an alternative of values of the same
        type</a:documentation>
      <choice>
	<ref name="type.attribute"/>
	<ref name="list.element"/>
	<ref name="data.type"/>
      </choice>
    </element>
  </define>

  <define name="list.element">
    <element name="s:list">
      <a:documentation>a list of values of the same
        type</a:documentation>
      <attribute name="ordered">
	<ref name="pml_schema_bool.type"/>
      </attribute>
      <choice>
	<group>
	  <attribute name="role">
	    <value datatypeLibrary="" type="string">#KNIT</value>
	  </attribute>
	  <attribute name="type">
	    <a:documentation>a reference to a named complex type
              for knitting</a:documentation>
	    <ref name="type_ref.type"/>
	  </attribute>
	  <ref name="cdata.element"/>
	</group>
        <group>
          <optional>
	    <ref name="role.attribute"/>
          </optional>
          <choice>
            <ref name="type.attribute"/>
    	    <ref name="alt.element"/>
 	    <ref name="data.type"/>
          </choice>
        </group>
      </choice>
    </element>
  </define>

  <define name="choice.element">
    <element name="s:choice">
      <a:documentation>enumerated type (atomic)</a:documentation>
      <oneOrMore>
	<element name="s:value">
	  <text/>
	</element>
      </oneOrMore>
    </element>
  </define>

  <define name="cdata.element">
    <element name="s:cdata">
      <a:documentation>cdata type (atomic)</a:documentation>
      <attribute name="format">
	<choice datatypeLibrary="">
	  <value type="string">any</value>
	  <value type="string">ID</value>
	  <value type="string">PMLREF</value>
          <value type="string">string</value>
          <value type="string">normalizedString</value>
          <value type="string">token</value>
          <value type="string">base64Binary</value>
          <value type="string">hexBinary</value>
          <value type="string">integer</value>
          <value type="string">positiveInteger</value>
          <value type="string">negativeInteger</value>
          <value type="string">nonNegativeInteger</value>
          <value type="string">nonPositiveInteger</value>
          <value type="string">long</value>
          <value type="string">unsignedLong</value>
          <value type="string">int</value>
          <value type="string">unsignedInt</value>
          <value type="string">short</value>
          <value type="string">unsignedShort</value>
          <value type="string">byte</value>
          <value type="string">unsignedByte</value>
          <value type="string">decimal</value>
          <value type="string">float</value>
          <value type="string">double</value>
          <value type="string">boolean</value>
          <value type="string">duration</value>
          <value type="string">dateTime</value>
          <value type="string">date</value>
          <value type="string">time</value>
          <value type="string">gYear</value>
          <value type="string">gYearMonth</value>
          <value type="string">gMonth</value>
          <value type="string">gMonthDay</value>
          <value type="string">gDay</value>
          <value type="string">Name</value>
          <value type="string">NCName</value>
          <value type="string">anyURI</value>
          <value type="string">language</value>
          <value type="string">IDREF</value>
          <value type="string">IDREFS</value>
          <value type="string">NMTOKEN</value>
          <value type="string">NMTOKENS</value>
	</choice>
      </attribute>
    </element>
  </define>

  <define name="constant.element">
    <element name="s:constant">
      <a:documentation>a constant (atomic)</a:documentation>
      <text/>
    </element>
  </define>

  <define name="sequence.element">
    <element name="s:sequence">
      <a:documentation>a sequence of elements</a:documentation>
      <optional><ref name="role.attribute"/></optional>
      <optional><attribute name="content_pattern"/></optional>
      <choice>
	<oneOrMore>
	  <ref name="element.element"/>
	</oneOrMore>
	<group>
	  <interleave>
	    <ref name="text.element"/>
	    <oneOrMore>
	      <ref name="element.element"/>
	    </oneOrMore>
	  </interleave>
	</group>
      </choice>
      <sch:pattern name="duplicite elements">
	<sch:rule context="s:element">
	  <sch:report test="count(../s:element[@name = current()/@name])>1">Sequence definition contains two or more element declarations with the same name.</sch:report>
	</sch:rule>
      </sch:pattern>
    </element>
  </define>

  <define name="text.element">
    <element name="s:text">
      <a:documentation>declare cdata for mixed-content
      sequence</a:documentation>
      <empty/>
    </element>
  </define>

  <define name="element.element">
    <element name="s:element">
      <a:documentation>an element of a sequence</a:documentation>
      <attribute name="name">
	<ref name="name.type"/>
      </attribute>
      <choice>
	<group>
	  <attribute name="role">
	    <value datatypeLibrary="" type="string">#KNIT</value>
	  </attribute>
	  <attribute name="type">
	    <a:documentation>a reference to a named complex type
	    for knitting</a:documentation>
	    <ref name="type_ref.type"/>
	  </attribute>
	  <ref name="cdata.element"/>
	</group>
	<group>
	  <optional>
	    <ref name="role.attribute"/>
	  </optional>
	  <ref name="type.decl"/>
	</group>
      </choice>
    </element>
  </define>

  <define name="container.element">
    <element name="s:container">
      <a:documentation>a simple container type</a:documentation>
      <optional>
	<ref name="role.attribute"/>
      </optional>
      <zeroOrMore>
	<ref name="attribute.element"/>
      </zeroOrMore>
      <optional>
	<choice>
	  <ref name="type.attribute"/>
	  <ref name="non-structure.type"/>
	</choice>
      </optional>
      <sch:pattern name="duplicite attributes">
	<sch:rule context="s:attribute">
	  <sch:report test="count(../s:attribute[@name = current()/@name])>1">Container definition two or more attribute declarations with the same name.</sch:report>
	</sch:rule>
      </sch:pattern>
    </element>
  </define>

  <define name="attribute.element">
    <element name="s:attribute">
      <a:documentation>attribute of a container</a:documentation>
      <optional><ref name="required.attribute"/></optional>
      <attribute name="name">
	<choice>
	  <data type="NCName"/>
	  <value type="Name">xml:id</value>
	</choice>
      </attribute>
      <optional>
	<ref name="role.attribute"/>
      </optional>
      <choice>
	<ref name="type.attribute"/>
	<choice>
	  <ref name="constant.element"/>
	  <ref name="choice.element"/>
	  <ref name="cdata.element"/>
	</choice>
      </choice>
    </element>
  </define>

  <define name="required.attribute">
    <attribute name="required">
      <ref name="pml_schema_bool.type"/>
    </attribute>
  </define>

  <define name="name.type">
    <data type="NCName">
      <except>
	<choice datatypeLibrary="">
	  <value type="string">LM</value>
	  <value type="string">AM</value>
	</choice>
      </except>
    </data>
  </define>
  <define name="revisionno.type">
    <data type="NMTOKEN">
      <param name="pattern">[0-9]+(\.[0-9]+)*</param>
    </data>
  </define>

  <define name="pml_schema_bool.type">
    <choice datatypeLibrary="">
      <value type="string">0</value>
      <value type="string">1</value>
    </choice>
  </define>

  <!-- we can only combine this with pml_schema_1_2.rng if we use NCName here -->
  <!-- See also pml_schema_1_1_strict.rng, where these are ID/IDREF -->
  <define name="type_name.type">
    <data type="NCName"/>
  </define>
  <define name="type_ref.type">
    <data type="NCName"/>
  </define>

</grammar>
